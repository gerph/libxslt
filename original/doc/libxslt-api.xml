<?xml version="1.0" encoding="ISO-8859-1"?>
<api name='libxslt'>
  <files>
    <file name='documents'>
     <exports symbol='xsltFindDocument'/>
     <exports symbol='xsltFreeDocuments'/>
     <exports symbol='xsltFreeStyleDocuments'/>
     <exports symbol='xsltLoadDocument'/>
     <exports symbol='xsltLoadStyleDocument'/>
     <exports symbol='xsltNewDocument'/>
     <exports symbol='xsltNewStyleDocument'/>
    </file>
    <file name='imports'>
     <exports symbol='XSLT_GET_IMPORT_INT'/>
     <exports symbol='XSLT_GET_IMPORT_PTR'/>
     <exports symbol='xsltFindElemSpaceHandling'/>
     <exports symbol='xsltFindTemplate'/>
     <exports symbol='xsltNeedElemSpaceHandling'/>
     <exports symbol='xsltNextImport'/>
     <exports symbol='xsltParseStylesheetImport'/>
     <exports symbol='xsltParseStylesheetInclude'/>
    </file>
    <file name='security'>
     <exports symbol='XSLT_SECPREF_CREATE_DIRECTORY'/>
     <exports symbol='XSLT_SECPREF_READ_FILE'/>
     <exports symbol='XSLT_SECPREF_READ_NETWORK'/>
     <exports symbol='XSLT_SECPREF_WRITE_FILE'/>
     <exports symbol='XSLT_SECPREF_WRITE_NETWORK'/>
     <exports symbol='xsltCheckRead'/>
     <exports symbol='xsltCheckWrite'/>
     <exports symbol='xsltFreeSecurityPrefs'/>
     <exports symbol='xsltGetDefaultSecurityPrefs'/>
     <exports symbol='xsltGetSecurityPrefs'/>
     <exports symbol='xsltNewSecurityPrefs'/>
     <exports symbol='xsltSecurityAllow'/>
     <exports symbol='xsltSecurityCheck'/>
     <exports symbol='xsltSecurityForbid'/>
     <exports symbol='xsltSecurityOption'/>
     <exports symbol='xsltSecurityPrefs'/>
     <exports symbol='xsltSecurityPrefsPtr'/>
     <exports symbol='xsltSetCtxtSecurityPrefs'/>
     <exports symbol='xsltSetDefaultSecurityPrefs'/>
     <exports symbol='xsltSetSecurityPrefs'/>
    </file>
    <file name='templates'>
     <exports symbol='xsltAttrListTemplateProcess'/>
     <exports symbol='xsltAttrTemplateProcess'/>
     <exports symbol='xsltAttrTemplateValueProcess'/>
     <exports symbol='xsltAttrTemplateValueProcessNode'/>
     <exports symbol='xsltEvalAttrValueTemplate'/>
     <exports symbol='xsltEvalStaticAttrValueTemplate'/>
     <exports symbol='xsltEvalTemplateString'/>
     <exports symbol='xsltEvalXPathPredicate'/>
     <exports symbol='xsltEvalXPathString'/>
     <exports symbol='xsltEvalXPathStringNs'/>
     <exports symbol='xsltTemplateProcess'/>
    </file>
    <file name='xsltexports'>
     <exports symbol='LIBXSLT_PUBLIC'/>
     <exports symbol='XSLTCALL'/>
     <exports symbol='XSLTPUBFUN'/>
     <exports symbol='XSLTPUBVAR'/>
     <exports symbol='_REENTRANT'/>
    </file>
    <file name='xsltutils'>
     <exports symbol='IS_XSLT_ELEM'/>
     <exports symbol='IS_XSLT_NAME'/>
     <exports symbol='IS_XSLT_REAL_NODE'/>
     <exports symbol='XSLT_DEBUG_CONT'/>
     <exports symbol='XSLT_DEBUG_INIT'/>
     <exports symbol='XSLT_DEBUG_NEXT'/>
     <exports symbol='XSLT_DEBUG_NONE'/>
     <exports symbol='XSLT_DEBUG_QUIT'/>
     <exports symbol='XSLT_DEBUG_RUN'/>
     <exports symbol='XSLT_DEBUG_RUN_RESTART'/>
     <exports symbol='XSLT_DEBUG_STEP'/>
     <exports symbol='XSLT_DEBUG_STEPOUT'/>
     <exports symbol='XSLT_DEBUG_STOP'/>
     <exports symbol='XSLT_STRANGE'/>
     <exports symbol='XSLT_TIMESTAMP_TICS_PER_SEC'/>
     <exports symbol='XSLT_TODO'/>
     <exports symbol='xslAddCall'/>
     <exports symbol='xslDebugStatus'/>
     <exports symbol='xslDropCall'/>
     <exports symbol='xsltAddCallCallback'/>
     <exports symbol='xsltCalibrateAdjust'/>
     <exports symbol='xsltComputeSortResult'/>
     <exports symbol='xsltDebugStatusCodes'/>
     <exports symbol='xsltDefaultSortFunction'/>
     <exports symbol='xsltDoSortFunction'/>
     <exports symbol='xsltDocumentSortFunction'/>
     <exports symbol='xsltDropCallCallback'/>
     <exports symbol='xsltGenericDebug'/>
     <exports symbol='xsltGenericDebugContext'/>
     <exports symbol='xsltGenericError'/>
     <exports symbol='xsltGenericErrorContext'/>
     <exports symbol='xsltGetNsProp'/>
     <exports symbol='xsltGetProfileInformation'/>
     <exports symbol='xsltGetQNameURI'/>
     <exports symbol='xsltGetUTF8Char'/>
     <exports symbol='xsltHandleDebuggerCallback'/>
     <exports symbol='xsltMessage'/>
     <exports symbol='xsltPrintErrorContext'/>
     <exports symbol='xsltSaveProfiling'/>
     <exports symbol='xsltSaveResultTo'/>
     <exports symbol='xsltSaveResultToFd'/>
     <exports symbol='xsltSaveResultToFile'/>
     <exports symbol='xsltSaveResultToFilename'/>
     <exports symbol='xsltSaveResultToString'/>
     <exports symbol='xsltSetCtxtSortFunc'/>
     <exports symbol='xsltSetDebuggerCallbacks'/>
     <exports symbol='xsltSetGenericDebugFunc'/>
     <exports symbol='xsltSetGenericErrorFunc'/>
     <exports symbol='xsltSetSortFunc'/>
     <exports symbol='xsltSetTransformErrorFunc'/>
     <exports symbol='xsltTimestamp'/>
     <exports symbol='xsltTransformError'/>
    </file>
    <file name='functions'>
     <exports symbol='XSLT_REGISTER_FUNCTION_LOOKUP'/>
     <exports symbol='xsltDocumentFunction'/>
     <exports symbol='xsltElementAvailableFunction'/>
     <exports symbol='xsltFormatNumberFunction'/>
     <exports symbol='xsltFunctionAvailableFunction'/>
     <exports symbol='xsltGenerateIdFunction'/>
     <exports symbol='xsltKeyFunction'/>
     <exports symbol='xsltRegisterAllFunctions'/>
     <exports symbol='xsltSystemPropertyFunction'/>
     <exports symbol='xsltUnparsedEntityURIFunction'/>
     <exports symbol='xsltXPathFunctionLookup'/>
    </file>
    <file name='namespaces'>
     <exports symbol='xsltCopyNamespace'/>
     <exports symbol='xsltCopyNamespaceList'/>
     <exports symbol='xsltFreeNamespaceAliasHashes'/>
     <exports symbol='xsltGetNamespace'/>
     <exports symbol='xsltGetSpecialNamespace'/>
     <exports symbol='xsltNamespaceAlias'/>
    </file>
    <file name='extra'>
     <exports symbol='XSLT_LIBXSLT_NAMESPACE'/>
     <exports symbol='XSLT_NORM_SAXON_NAMESPACE'/>
     <exports symbol='XSLT_SAXON_NAMESPACE'/>
     <exports symbol='XSLT_XALAN_NAMESPACE'/>
     <exports symbol='XSLT_XT_NAMESPACE'/>
     <exports symbol='xsltDebug'/>
     <exports symbol='xsltFunctionNodeSet'/>
     <exports symbol='xsltRegisterAllExtras'/>
     <exports symbol='xsltRegisterExtras'/>
    </file>
    <file name='xsltInternals'>
     <exports symbol='CHECK_STOPPED'/>
     <exports symbol='CHECK_STOPPED0'/>
     <exports symbol='CHECK_STOPPEDE'/>
     <exports symbol='XSLT_FUNC_APPLYIMPORTS'/>
     <exports symbol='XSLT_FUNC_APPLYTEMPLATES'/>
     <exports symbol='XSLT_FUNC_ATTRIBUTE'/>
     <exports symbol='XSLT_FUNC_CALLTEMPLATE'/>
     <exports symbol='XSLT_FUNC_CHOOSE'/>
     <exports symbol='XSLT_FUNC_COMMENT'/>
     <exports symbol='XSLT_FUNC_COPY'/>
     <exports symbol='XSLT_FUNC_COPYOF'/>
     <exports symbol='XSLT_FUNC_DOCUMENT'/>
     <exports symbol='XSLT_FUNC_ELEMENT'/>
     <exports symbol='XSLT_FUNC_EXTENSION'/>
     <exports symbol='XSLT_FUNC_FOREACH'/>
     <exports symbol='XSLT_FUNC_IF'/>
     <exports symbol='XSLT_FUNC_NUMBER'/>
     <exports symbol='XSLT_FUNC_PARAM'/>
     <exports symbol='XSLT_FUNC_PI'/>
     <exports symbol='XSLT_FUNC_SORT'/>
     <exports symbol='XSLT_FUNC_TEXT'/>
     <exports symbol='XSLT_FUNC_VALUEOF'/>
     <exports symbol='XSLT_FUNC_VARIABLE'/>
     <exports symbol='XSLT_FUNC_WHEN'/>
     <exports symbol='XSLT_FUNC_WITHPARAM'/>
     <exports symbol='XSLT_MAX_SORT'/>
     <exports symbol='XSLT_OUTPUT_HTML'/>
     <exports symbol='XSLT_OUTPUT_TEXT'/>
     <exports symbol='XSLT_OUTPUT_XML'/>
     <exports symbol='XSLT_PAT_NO_PRIORITY'/>
     <exports symbol='XSLT_RUNTIME_EXTRA'/>
     <exports symbol='XSLT_RUNTIME_EXTRA_FREE'/>
     <exports symbol='XSLT_RUNTIME_EXTRA_LST'/>
     <exports symbol='XSLT_STATE_ERROR'/>
     <exports symbol='XSLT_STATE_OK'/>
     <exports symbol='XSLT_STATE_STOPPED'/>
     <exports symbol='_xsltDecimalFormat'/>
     <exports symbol='_xsltDocument'/>
     <exports symbol='_xsltElemPreComp'/>
     <exports symbol='_xsltRuntimeExtra'/>
     <exports symbol='_xsltStackElem'/>
     <exports symbol='_xsltStylePreComp'/>
     <exports symbol='_xsltStylesheet'/>
     <exports symbol='_xsltTemplate'/>
     <exports symbol='_xsltTransformContext'/>
     <exports symbol='xsltAllocateExtra'/>
     <exports symbol='xsltAllocateExtraCtxt'/>
     <exports symbol='xsltCreateRVT'/>
     <exports symbol='xsltDecimalFormat'/>
     <exports symbol='xsltDecimalFormatGetByName'/>
     <exports symbol='xsltDecimalFormatPtr'/>
     <exports symbol='xsltDocument'/>
     <exports symbol='xsltDocumentPtr'/>
     <exports symbol='xsltElemPreComp'/>
     <exports symbol='xsltElemPreCompDeallocator'/>
     <exports symbol='xsltElemPreCompPtr'/>
     <exports symbol='xsltFormatNumberConversion'/>
     <exports symbol='xsltFreeRVTs'/>
     <exports symbol='xsltFreeStackElemList'/>
     <exports symbol='xsltFreeStylesheet'/>
     <exports symbol='xsltIsBlank'/>
     <exports symbol='xsltLoadStylesheetPI'/>
     <exports symbol='xsltNewStylesheet'/>
     <exports symbol='xsltNumberFormat'/>
     <exports symbol='xsltOutputType'/>
     <exports symbol='xsltParseStylesheetDoc'/>
     <exports symbol='xsltParseStylesheetFile'/>
     <exports symbol='xsltParseStylesheetImportedDoc'/>
     <exports symbol='xsltParseStylesheetOutput'/>
     <exports symbol='xsltParseStylesheetProcess'/>
     <exports symbol='xsltParseTemplateContent'/>
     <exports symbol='xsltRegisterPersistRVT'/>
     <exports symbol='xsltRegisterTmpRVT'/>
     <exports symbol='xsltRuntimeExtra'/>
     <exports symbol='xsltRuntimeExtraPtr'/>
     <exports symbol='xsltSortFunc'/>
     <exports symbol='xsltStackElem'/>
     <exports symbol='xsltStackElemPtr'/>
     <exports symbol='xsltStylePreComp'/>
     <exports symbol='xsltStylePreCompPtr'/>
     <exports symbol='xsltStyleType'/>
     <exports symbol='xsltStylesheet'/>
     <exports symbol='xsltStylesheetPtr'/>
     <exports symbol='xsltTemplate'/>
     <exports symbol='xsltTemplatePtr'/>
     <exports symbol='xsltTransformContext'/>
     <exports symbol='xsltTransformContextPtr'/>
     <exports symbol='xsltTransformFunction'/>
     <exports symbol='xsltTransformState'/>
    </file>
    <file name='transform'>
     <exports symbol='xslHandleDebugger'/>
     <exports symbol='xsltApplyImports'/>
     <exports symbol='xsltApplyOneTemplate'/>
     <exports symbol='xsltApplyStripSpaces'/>
     <exports symbol='xsltApplyStylesheet'/>
     <exports symbol='xsltApplyStylesheetUser'/>
     <exports symbol='xsltApplyTemplates'/>
     <exports symbol='xsltAttribute'/>
     <exports symbol='xsltCallTemplate'/>
     <exports symbol='xsltChoose'/>
     <exports symbol='xsltComment'/>
     <exports symbol='xsltCopy'/>
     <exports symbol='xsltCopyOf'/>
     <exports symbol='xsltCopyTextString'/>
     <exports symbol='xsltDocumentElem'/>
     <exports symbol='xsltElement'/>
     <exports symbol='xsltForEach'/>
     <exports symbol='xsltFreeTransformContext'/>
     <exports symbol='xsltGetXIncludeDefault'/>
     <exports symbol='xsltIf'/>
     <exports symbol='xsltNewTransformContext'/>
     <exports symbol='xsltNumber'/>
     <exports symbol='xsltProcessingInstruction'/>
     <exports symbol='xsltProfileStylesheet'/>
     <exports symbol='xsltRegisterAllElement'/>
     <exports symbol='xsltRunStylesheet'/>
     <exports symbol='xsltRunStylesheetUser'/>
     <exports symbol='xsltSetXIncludeDefault'/>
     <exports symbol='xsltSort'/>
     <exports symbol='xsltText'/>
     <exports symbol='xsltValueOf'/>
    </file>
    <file name='attributes'>
     <exports symbol='xsltApplyAttributeSet'/>
     <exports symbol='xsltFreeAttributeSetsHashes'/>
     <exports symbol='xsltParseStylesheetAttributeSet'/>
     <exports symbol='xsltResolveStylesheetAttributeSet'/>
    </file>
    <file name='extensions'>
     <exports symbol='xsltCheckExtPrefix'/>
     <exports symbol='xsltDebugDumpExtensions'/>
     <exports symbol='xsltExtElementLookup'/>
     <exports symbol='xsltExtFunctionLookup'/>
     <exports symbol='xsltExtInitFunction'/>
     <exports symbol='xsltExtModuleElementLookup'/>
     <exports symbol='xsltExtModuleElementPreComputeLookup'/>
     <exports symbol='xsltExtModuleFunctionLookup'/>
     <exports symbol='xsltExtModuleTopLevelLookup'/>
     <exports symbol='xsltExtShutdownFunction'/>
     <exports symbol='xsltFreeCtxtExts'/>
     <exports symbol='xsltFreeExts'/>
     <exports symbol='xsltGetExtData'/>
     <exports symbol='xsltGetExtInfo'/>
     <exports symbol='xsltInitCtxtExts'/>
     <exports symbol='xsltInitElemPreComp'/>
     <exports symbol='xsltNewElemPreComp'/>
     <exports symbol='xsltPreComputeExtModuleElement'/>
     <exports symbol='xsltPreComputeFunction'/>
     <exports symbol='xsltRegisterExtElement'/>
     <exports symbol='xsltRegisterExtFunction'/>
     <exports symbol='xsltRegisterExtModule'/>
     <exports symbol='xsltRegisterExtModuleElement'/>
     <exports symbol='xsltRegisterExtModuleFull'/>
     <exports symbol='xsltRegisterExtModuleFunction'/>
     <exports symbol='xsltRegisterExtModuleTopLevel'/>
     <exports symbol='xsltRegisterExtPrefix'/>
     <exports symbol='xsltRegisterTestModule'/>
     <exports symbol='xsltShutdownCtxtExts'/>
     <exports symbol='xsltShutdownExts'/>
     <exports symbol='xsltStyleExtInitFunction'/>
     <exports symbol='xsltStyleExtShutdownFunction'/>
     <exports symbol='xsltStyleGetExtData'/>
     <exports symbol='xsltTopLevelFunction'/>
     <exports symbol='xsltUnregisterExtModule'/>
     <exports symbol='xsltUnregisterExtModuleElement'/>
     <exports symbol='xsltUnregisterExtModuleFunction'/>
     <exports symbol='xsltUnregisterExtModuleTopLevel'/>
     <exports symbol='xsltXPathGetTransformContext'/>
    </file>
    <file name='keys'>
     <exports symbol='xsltAddKey'/>
     <exports symbol='xsltFreeDocumentKeys'/>
     <exports symbol='xsltFreeKeys'/>
     <exports symbol='xsltGetKey'/>
     <exports symbol='xsltInitCtxtKeys'/>
    </file>
    <file name='numbersInternals'>
     <exports symbol='_xsltFormatNumberInfo'/>
     <exports symbol='_xsltNumberData'/>
     <exports symbol='xsltFormatNumberInfo'/>
     <exports symbol='xsltFormatNumberInfoPtr'/>
     <exports symbol='xsltNumberData'/>
     <exports symbol='xsltNumberDataPtr'/>
    </file>
    <file name='xslt'>
     <exports symbol='XSLT_DEFAULT_URL'/>
     <exports symbol='XSLT_DEFAULT_VENDOR'/>
     <exports symbol='XSLT_DEFAULT_VERSION'/>
     <exports symbol='XSLT_NAMESPACE'/>
     <exports symbol='xsltCleanupGlobals'/>
     <exports symbol='xsltEngineVersion'/>
     <exports symbol='xsltLibxmlVersion'/>
     <exports symbol='xsltLibxsltVersion'/>
     <exports symbol='xsltMaxDepth'/>
    </file>
    <file name='preproc'>
     <exports symbol='xsltDocumentComp'/>
     <exports symbol='xsltExtMarker'/>
     <exports symbol='xsltFreeStylePreComps'/>
     <exports symbol='xsltStylePreCompute'/>
    </file>
    <file name='variables'>
     <exports symbol='XSLT_REGISTER_VARIABLE_LOOKUP'/>
     <exports symbol='xsltAddStackElemList'/>
     <exports symbol='xsltEvalGlobalVariables'/>
     <exports symbol='xsltEvalOneUserParam'/>
     <exports symbol='xsltEvalUserParams'/>
     <exports symbol='xsltFreeGlobalVariables'/>
     <exports symbol='xsltParseGlobalParam'/>
     <exports symbol='xsltParseGlobalVariable'/>
     <exports symbol='xsltParseStylesheetCallerParam'/>
     <exports symbol='xsltParseStylesheetParam'/>
     <exports symbol='xsltParseStylesheetVariable'/>
     <exports symbol='xsltQuoteOneUserParam'/>
     <exports symbol='xsltQuoteUserParams'/>
     <exports symbol='xsltVariableLookup'/>
     <exports symbol='xsltXPathVariableLookup'/>
    </file>
    <file name='pattern'>
     <exports symbol='xsltAddTemplate'/>
     <exports symbol='xsltCleanupTemplates'/>
     <exports symbol='xsltCompMatch'/>
     <exports symbol='xsltCompMatchPtr'/>
     <exports symbol='xsltCompilePattern'/>
     <exports symbol='xsltFreeCompMatchList'/>
     <exports symbol='xsltFreeTemplateHashes'/>
     <exports symbol='xsltGetTemplate'/>
     <exports symbol='xsltMatchPattern'/>
     <exports symbol='xsltNormalizeCompSteps'/>
     <exports symbol='xsltTestCompMatchList'/>
    </file>
  </files>
  <symbols>
    <macro name='CHECK_STOPPED' file='xsltInternals'>
      <info>Macro to check if the XSLT processing should be stopped. Will return from the function.</info>
    </macro>
    <macro name='CHECK_STOPPED0' file='xsltInternals'>
      <info>Macro to check if the XSLT processing should be stopped. Will return from the function with a 0 value.</info>
    </macro>
    <macro name='CHECK_STOPPEDE' file='xsltInternals'>
      <info>Macro to check if the XSLT processing should be stopped. Will goto the error: label.</info>
    </macro>
    <macro name='IS_XSLT_ELEM' file='xsltutils'>
      <info>Checks that the element pertains to XSLT namespace.</info>
    </macro>
    <macro name='IS_XSLT_NAME' file='xsltutils'>
      <info>Checks the value of an element in XSLT namespace.</info>
    </macro>
    <macro name='IS_XSLT_REAL_NODE' file='xsltutils'>
      <info>Check that a node is a &apos;real&apos; one: document, element, text or attribute.</info>
    </macro>
    <macro name='LIBXSLT_PUBLIC' file='xsltexports'>
    </macro>
    <macro name='XSLTCALL' file='xsltexports'>
    </macro>
    <macro name='XSLTPUBFUN' file='xsltexports'>
    </macro>
    <macro name='XSLTPUBVAR' file='xsltexports'>
    </macro>
    <macro name='XSLT_DEFAULT_URL' file='xslt'>
      <info>The XSLT &quot;vendor&quot; URL for this processor.</info>
    </macro>
    <macro name='XSLT_DEFAULT_VENDOR' file='xslt'>
      <info>The XSLT &quot;vendor&quot; string for this processor.</info>
    </macro>
    <macro name='XSLT_DEFAULT_VERSION' file='xslt'>
      <info>The default version of XSLT supported.</info>
    </macro>
    <macro name='XSLT_GET_IMPORT_INT' file='imports'>
      <info>A macro to import intergers from the stylesheet cascading order.</info>
    </macro>
    <macro name='XSLT_GET_IMPORT_PTR' file='imports'>
      <info>A macro to import pointers from the stylesheet cascading order.</info>
    </macro>
    <macro name='XSLT_LIBXSLT_NAMESPACE' file='extra'>
      <info>This is the libxslt namespace for specific extensions.</info>
    </macro>
    <macro name='XSLT_MAX_SORT' file='xsltInternals'>
      <info>Max number of specified xsl:sort on an element.</info>
    </macro>
    <macro name='XSLT_NAMESPACE' file='xslt'>
      <info>The XSLT specification namespace.</info>
    </macro>
    <macro name='XSLT_NORM_SAXON_NAMESPACE' file='extra'>
      <info>This is Norm&apos;s namespace for SAXON extensions.</info>
    </macro>
    <macro name='XSLT_PAT_NO_PRIORITY' file='xsltInternals'>
      <info>Specific value for pattern without priority expressed.</info>
    </macro>
    <macro name='XSLT_REGISTER_FUNCTION_LOOKUP' file='functions'>
      <info>Registering macro, not general purpose at all but used in different modules.</info>
    </macro>
    <macro name='XSLT_REGISTER_VARIABLE_LOOKUP' file='variables'>
      <info>Registering macro, not general purpose at all but used in different modules.</info>
    </macro>
    <macro name='XSLT_RUNTIME_EXTRA' file='xsltInternals'>
      <info>Macro used to define extra information stored in the context</info>
      <arg name='ctxt' info='the transformation context'/>
      <arg name='nr' info='the index'/>
    </macro>
    <macro name='XSLT_RUNTIME_EXTRA_FREE' file='xsltInternals'>
      <info>Macro used to free extra information stored in the context</info>
      <arg name='ctxt' info='the transformation context'/>
      <arg name='nr' info='the index'/>
    </macro>
    <macro name='XSLT_RUNTIME_EXTRA_LST' file='xsltInternals'>
      <info>Macro used to access extra information stored in the context</info>
      <arg name='ctxt' info='the transformation context'/>
      <arg name='nr' info='the index'/>
    </macro>
    <macro name='XSLT_SAXON_NAMESPACE' file='extra'>
      <info>This is Michael Kay&apos;s Saxon processor namespace for extensions.</info>
    </macro>
    <macro name='XSLT_STRANGE' file='xsltutils'>
      <info>Macro to flag that a problem was detected internally.</info>
    </macro>
    <macro name='XSLT_TIMESTAMP_TICS_PER_SEC' file='xsltutils'>
      <info>Sampling precision for profiling</info>
    </macro>
    <macro name='XSLT_TODO' file='xsltutils'>
      <info>Macro to flag unimplemented blocks.</info>
    </macro>
    <macro name='XSLT_XALAN_NAMESPACE' file='extra'>
      <info>This is the Apache project XALAN processor namespace for extensions.</info>
    </macro>
    <macro name='XSLT_XT_NAMESPACE' file='extra'>
      <info>This is James Clark&apos;s XT processor namespace for extensions.</info>
    </macro>
    <macro name='_REENTRANT' file='xsltexports'>
    </macro>
    <enum name='XSLT_DEBUG_CONT' file='xsltutils' value='6' type='xsltDebugStatusCodes'/>
    <enum name='XSLT_DEBUG_INIT' file='xsltutils' value='1' type='xsltDebugStatusCodes'/>
    <enum name='XSLT_DEBUG_NEXT' file='xsltutils' value='4' type='xsltDebugStatusCodes'/>
    <enum name='XSLT_DEBUG_NONE' file='xsltutils' value='0' type='xsltDebugStatusCodes' info='no debugging allowed'/>
    <enum name='XSLT_DEBUG_QUIT' file='xsltutils' value='9' type='xsltDebugStatusCodes'/>
    <enum name='XSLT_DEBUG_RUN' file='xsltutils' value='7' type='xsltDebugStatusCodes'/>
    <enum name='XSLT_DEBUG_RUN_RESTART' file='xsltutils' value='8' type='xsltDebugStatusCodes'/>
    <enum name='XSLT_DEBUG_STEP' file='xsltutils' value='2' type='xsltDebugStatusCodes'/>
    <enum name='XSLT_DEBUG_STEPOUT' file='xsltutils' value='3' type='xsltDebugStatusCodes'/>
    <enum name='XSLT_DEBUG_STOP' file='xsltutils' value='5' type='xsltDebugStatusCodes'/>
    <enum name='XSLT_FUNC_APPLYIMPORTS' file='xsltInternals' value='11' type='xsltStyleType'/>
    <enum name='XSLT_FUNC_APPLYTEMPLATES' file='xsltInternals' value='13' type='xsltStyleType'/>
    <enum name='XSLT_FUNC_ATTRIBUTE' file='xsltInternals' value='5' type='xsltStyleType'/>
    <enum name='XSLT_FUNC_CALLTEMPLATE' file='xsltInternals' value='12' type='xsltStyleType'/>
    <enum name='XSLT_FUNC_CHOOSE' file='xsltInternals' value='14' type='xsltStyleType'/>
    <enum name='XSLT_FUNC_COMMENT' file='xsltInternals' value='6' type='xsltStyleType'/>
    <enum name='XSLT_FUNC_COPY' file='xsltInternals' value='1' type='xsltStyleType'/>
    <enum name='XSLT_FUNC_COPYOF' file='xsltInternals' value='8' type='xsltStyleType'/>
    <enum name='XSLT_FUNC_DOCUMENT' file='xsltInternals' value='17' type='xsltStyleType'/>
    <enum name='XSLT_FUNC_ELEMENT' file='xsltInternals' value='4' type='xsltStyleType'/>
    <enum name='XSLT_FUNC_EXTENSION' file='xsltInternals' value='22' type='xsltStyleType'/>
    <enum name='XSLT_FUNC_FOREACH' file='xsltInternals' value='16' type='xsltStyleType'/>
    <enum name='XSLT_FUNC_IF' file='xsltInternals' value='15' type='xsltStyleType'/>
    <enum name='XSLT_FUNC_NUMBER' file='xsltInternals' value='10' type='xsltStyleType'/>
    <enum name='XSLT_FUNC_PARAM' file='xsltInternals' value='19' type='xsltStyleType'/>
    <enum name='XSLT_FUNC_PI' file='xsltInternals' value='7' type='xsltStyleType'/>
    <enum name='XSLT_FUNC_SORT' file='xsltInternals' value='2' type='xsltStyleType'/>
    <enum name='XSLT_FUNC_TEXT' file='xsltInternals' value='3' type='xsltStyleType'/>
    <enum name='XSLT_FUNC_VALUEOF' file='xsltInternals' value='9' type='xsltStyleType'/>
    <enum name='XSLT_FUNC_VARIABLE' file='xsltInternals' value='20' type='xsltStyleType'/>
    <enum name='XSLT_FUNC_WHEN' file='xsltInternals' value='21' type='xsltStyleType'/>
    <enum name='XSLT_FUNC_WITHPARAM' file='xsltInternals' value='18' type='xsltStyleType'/>
    <enum name='XSLT_OUTPUT_HTML' file='xsltInternals' value='1' type='xsltOutputType'/>
    <enum name='XSLT_OUTPUT_TEXT' file='xsltInternals' value='2' type='xsltOutputType'/>
    <enum name='XSLT_OUTPUT_XML' file='xsltInternals' value='0' type='xsltOutputType'/>
    <enum name='XSLT_SECPREF_CREATE_DIRECTORY' file='security' value='3' type='xsltSecurityOption'/>
    <enum name='XSLT_SECPREF_READ_FILE' file='security' value='1' type='xsltSecurityOption'/>
    <enum name='XSLT_SECPREF_READ_NETWORK' file='security' value='4' type='xsltSecurityOption'/>
    <enum name='XSLT_SECPREF_WRITE_FILE' file='security' value='2' type='xsltSecurityOption'/>
    <enum name='XSLT_SECPREF_WRITE_NETWORK' file='security' value='5' type='xsltSecurityOption'/>
    <enum name='XSLT_STATE_ERROR' file='xsltInternals' value='1' type='xsltTransformState'/>
    <enum name='XSLT_STATE_OK' file='xsltInternals' value='0' type='xsltTransformState'/>
    <enum name='XSLT_STATE_STOPPED' file='xsltInternals' value='2' type='xsltTransformState'/>
    <struct name='xsltCompMatch' file='pattern' type='struct _xsltCompMatch'/>
    <typedef name='xsltCompMatchPtr' file='pattern' type='xsltCompMatch *'/>
    <typedef name='xsltDebugStatusCodes' file='xsltutils' type='enum'/>
    <struct name='xsltDecimalFormat' file='xsltInternals' type='struct _xsltDecimalFormat'>
      <field name='next' type='struct _xsltDecimalFormat *' info=' chained list'/>
      <field name='name' type='xmlChar *' info=' Used for interpretation of pattern'/>
      <field name='digit' type='xmlChar *' info=''/>
      <field name='patternSeparator' type='xmlChar *' info=' May appear in result'/>
      <field name='minusSign' type='xmlChar *' info=''/>
      <field name='infinity' type='xmlChar *' info=''/>
      <field name='noNumber' type='xmlChar *' info=' Not-a-number Used for interpretation of pattern and may appear in result'/>
      <field name='decimalPoint' type='xmlChar *' info=''/>
      <field name='grouping' type='xmlChar *' info=''/>
      <field name='percent' type='xmlChar *' info=''/>
      <field name='permille' type='xmlChar *' info=''/>
      <field name='zeroDigit' type='xmlChar *' info=''/>
    </struct>
    <typedef name='xsltDecimalFormatPtr' file='xsltInternals' type='xsltDecimalFormat *'/>
    <struct name='xsltDocument' file='xsltInternals' type='struct _xsltDocument'>
      <field name='next' type='struct _xsltDocument *' info=' documents are kept in a chained list'/>
      <field name='main' type='int' info=' is this the main document'/>
      <field name='doc' type='xmlDocPtr' info=' the parsed document'/>
      <field name='keys' type='void *' info=' key tables storage'/>
    </struct>
    <typedef name='xsltDocumentPtr' file='xsltInternals' type='xsltDocument *'/>
    <struct name='xsltElemPreComp' file='xsltInternals' type='struct _xsltElemPreComp'>
      <field name='next' type='xsltElemPreCompPtr' info=' chained list'/>
      <field name='type' type='xsltStyleType' info=' type of the element'/>
      <field name='func' type='xsltTransformFunction' info=' handling function'/>
      <field name='inst' type='xmlNodePtr' info=' the instruction end of common part'/>
      <field name='free' type='xsltElemPreCompDeallocator' info=' the deallocator'/>
    </struct>
    <typedef name='xsltElemPreCompPtr' file='xsltInternals' type='xsltElemPreComp *'/>
    <struct name='xsltFormatNumberInfo' file='numbersInternals' type='struct _xsltFormatNumberInfo'>
      <field name='integer_hash' type='int' info=' Number of &apos;#&apos; in integer part'/>
      <field name='integer_digits' type='int' info=' Number of &apos;0&apos; in integer part'/>
      <field name='frac_digits' type='int' info=' Number of &apos;0&apos; in fractional part'/>
      <field name='frac_hash' type='int' info=' Number of &apos;#&apos; in fractional part'/>
      <field name='group' type='int' info=' Number of chars per display &apos;group&apos;'/>
      <field name='multiplier' type='int' info=' Scaling for percent or permille'/>
      <field name='add_decimal' type='char' info=' Flag for whether decimal point appears in pattern'/>
      <field name='is_multiplier_set' type='char' info=' Flag to catch multiple occurences of percent/permille'/>
      <field name='is_negative_pattern' type='char' info=' Flag for processing -ve prefix/suffix'/>
    </struct>
    <typedef name='xsltFormatNumberInfoPtr' file='numbersInternals' type='xsltFormatNumberInfo *'/>
    <struct name='xsltNumberData' file='numbersInternals' type='struct _xsltNumberData'>
      <field name='level' type='xmlChar *' info=''/>
      <field name='count' type='xmlChar *' info=''/>
      <field name='from' type='xmlChar *' info=''/>
      <field name='value' type='xmlChar *' info=''/>
      <field name='format' type='xmlChar *' info=''/>
      <field name='has_format' type='int' info=''/>
      <field name='digitsPerGroup' type='int' info=''/>
      <field name='groupingCharacter' type='int' info=''/>
      <field name='groupingCharacterLen' type='int' info=''/>
      <field name='doc' type='xmlDocPtr' info=''/>
      <field name='node' type='xmlNodePtr' info='* accelerators
*'/>
    </struct>
    <typedef name='xsltNumberDataPtr' file='numbersInternals' type='xsltNumberData *'/>
    <typedef name='xsltOutputType' file='xsltInternals' type='enum'/>
    <struct name='xsltRuntimeExtra' file='xsltInternals' type='struct _xsltRuntimeExtra'>
      <field name='info' type='void *' info=' pointer to the extra data'/>
      <field name='deallocate' type='xmlFreeFunc' info=' pointer to the deallocation routine'/>
      <field name='val' type='void *' info=' data not needing deallocation'/>
    </struct>
    <typedef name='xsltRuntimeExtraPtr' file='xsltInternals' type='xsltRuntimeExtra *'/>
    <typedef name='xsltSecurityOption' file='security' type='enum'/>
    <struct name='xsltSecurityPrefs' file='security' type='struct _xsltSecurityPrefs'/>
    <typedef name='xsltSecurityPrefsPtr' file='security' type='xsltSecurityPrefs *'/>
    <struct name='xsltStackElem' file='xsltInternals' type='struct _xsltStackElem'>
      <field name='next' type='struct _xsltStackElem *' info=' chained list'/>
      <field name='comp' type='xsltStylePreCompPtr' info=' the compiled form'/>
      <field name='computed' type='int' info=' was the evaluation done'/>
      <field name='name' type='xmlChar *' info=' the local part of the name QName'/>
      <field name='nameURI' type='xmlChar *' info=' the URI part of the name QName'/>
      <field name='select' type='xmlChar *' info=' the eval string'/>
      <field name='tree' type='xmlNodePtr' info=' the tree if no eval string or the location'/>
      <field name='value' type='xmlXPathObjectPtr' info=' The value if computed'/>
    </struct>
    <typedef name='xsltStackElemPtr' file='xsltInternals' type='xsltStackElem *'/>
    <struct name='xsltStylePreComp' file='xsltInternals' type='struct _xsltStylePreComp'>
      <field name='next' type='xsltElemPreCompPtr' info=' chained list'/>
      <field name='type' type='xsltStyleType' info=' type of the element'/>
      <field name='func' type='xsltTransformFunction' info=' handling function'/>
      <field name='inst' type='xmlNodePtr' info='* Pre computed values.
*'/>
      <field name='stype' type='xmlChar *' info=' sort'/>
      <field name='has_stype' type='int' info=' sort'/>
      <field name='number' type='int' info=' sort'/>
      <field name='order' type='xmlChar *' info=' sort'/>
      <field name='has_order' type='int' info=' sort'/>
      <field name='descending' type='int' info=' sort'/>
      <field name='lang' type='xmlChar *' info=' sort'/>
      <field name='has_lang' type='int' info=' sort'/>
      <field name='case_order' type='xmlChar *' info=' sort'/>
      <field name='lower_first' type='int' info=' sort'/>
      <field name='use' type='xmlChar *' info=' copy, element'/>
      <field name='has_use' type='int' info=' copy, element'/>
      <field name='noescape' type='int' info=' text'/>
      <field name='name' type='xmlChar *' info=' element, attribute, pi'/>
      <field name='has_name' type='int' info=' element, attribute, pi'/>
      <field name='ns' type='xmlChar *' info=' element'/>
      <field name='has_ns' type='int' info=' element'/>
      <field name='mode' type='xmlChar *' info=' apply-templates'/>
      <field name='modeURI' type='xmlChar *' info=' apply-templates'/>
      <field name='test' type='xmlChar *' info=' if'/>
      <field name='templ' type='xsltTemplatePtr' info=' call-template'/>
      <field name='select' type='xmlChar *' info=' sort, copy-of, value-of, apply-templates'/>
      <field name='ver11' type='int' info=' document'/>
      <field name='filename' type='xmlChar *' info=' document URL'/>
      <field name='has_filename' type='int' info=' document'/>
      <field name='numdata' type='xsltNumberData' info=' number'/>
      <field name='comp' type='xmlXPathCompExprPtr' info=' a precompiled XPath expression'/>
      <field name='nsList' type='xmlNsPtr *' info=' the namespaces in scope'/>
      <field name='nsNr' type='int' info=' the number of namespaces in scope'/>
    </struct>
    <typedef name='xsltStylePreCompPtr' file='xsltInternals' type='xsltStylePreComp *'/>
    <typedef name='xsltStyleType' file='xsltInternals' type='enum'/>
    <struct name='xsltStylesheet' file='xsltInternals' type='struct _xsltStylesheet'>
      <field name='parent' type='struct _xsltStylesheet *' info=''/>
      <field name='next' type='struct _xsltStylesheet *' info=''/>
      <field name='imports' type='struct _xsltStylesheet *' info=''/>
      <field name='docList' type='xsltDocumentPtr' info='* General data on the style sheet document.
*'/>
      <field name='doc' type='xmlDocPtr' info=' the parsed XML stylesheet'/>
      <field name='stripSpaces' type='xmlHashTablePtr' info=' the hash table of the strip-space and
preserve space elements'/>
      <field name='stripAll' type='int' info=' strip-space * (1) preserve-space * (-1)'/>
      <field name='cdataSection' type='xmlHashTablePtr' info='* Global variable or parameters.
*'/>
      <field name='variables' type='xsltStackElemPtr' info='* Template descriptions.
*'/>
      <field name='templates' type='xsltTemplatePtr' info=' the ordered list of templates'/>
      <field name='templatesHash' type='void *' info=' hash table or wherever compiled templates
informations are stored'/>
      <field name='rootMatch' type='void *' info=' template based on /'/>
      <field name='keyMatch' type='void *' info=' template based on key()'/>
      <field name='elemMatch' type='void *' info=' template based on *'/>
      <field name='attrMatch' type='void *' info=' template based on @*'/>
      <field name='parentMatch' type='void *' info=' template based on ..'/>
      <field name='textMatch' type='void *' info=' template based on text()'/>
      <field name='piMatch' type='void *' info=' template based on processing-instruction()'/>
      <field name='commentMatch' type='void *' info='* Namespace aliases.
*'/>
      <field name='nsAliases' type='xmlHashTablePtr' info='* Attribute sets.
*'/>
      <field name='attributeSets' type='xmlHashTablePtr' info='* Namespaces.
*'/>
      <field name='nsHash' type='xmlHashTablePtr' info=' the set of namespaces in use'/>
      <field name='nsDefs' type='void *' info='* Key definitions.
*'/>
      <field name='keys' type='void *' info='* Output related stuff.
*'/>
      <field name='method' type='xmlChar *' info=' the output method'/>
      <field name='methodURI' type='xmlChar *' info=' associated namespace if any'/>
      <field name='version' type='xmlChar *' info=' version string'/>
      <field name='encoding' type='xmlChar *' info=' encoding string'/>
      <field name='omitXmlDeclaration' type='int' info='* Number formatting.
*'/>
      <field name='decimalFormat' type='xsltDecimalFormatPtr' info=''/>
      <field name='standalone' type='int' info=' standalone = &quot;yes&quot; | &quot;no&quot;'/>
      <field name='doctypePublic' type='xmlChar *' info=' doctype-public string'/>
      <field name='doctypeSystem' type='xmlChar *' info=' doctype-system string'/>
      <field name='indent' type='int' info=' should output being indented'/>
      <field name='mediaType' type='xmlChar *' info='* Precomputed blocks.
*'/>
      <field name='preComps' type='xsltElemPreCompPtr' info=' list of precomputed blocks'/>
      <field name='warnings' type='int' info=' number of warnings found at compilation'/>
      <field name='errors' type='int' info=' number of errors found at compilation'/>
      <field name='exclPrefix' type='xmlChar *' info=' last excluded prefixes'/>
      <field name='exclPrefixTab' type='xmlChar **' info=' array of excluded prefixes'/>
      <field name='exclPrefixNr' type='int' info=' number of excluded prefixes in scope'/>
      <field name='exclPrefixMax' type='int' info=' size of the array'/>
      <field name='_private' type='void *' info='* Extensions.
*'/>
      <field name='extInfos' type='xmlHashTablePtr' info=' the extension data'/>
      <field name='extrasNr' type='int' info=' the number of extras required'/>
    </struct>
    <typedef name='xsltStylesheetPtr' file='xsltInternals' type='xsltStylesheet *'/>
    <struct name='xsltTemplate' file='xsltInternals' type='struct _xsltTemplate'>
      <field name='next' type='struct _xsltTemplate *' info=' chained list sorted by priority'/>
      <field name='style' type='struct _xsltStylesheet *' info=' the containing stylesheet'/>
      <field name='match' type='xmlChar *' info=' the matching string'/>
      <field name='priority' type='float' info=' as given from the stylesheet, not computed'/>
      <field name='name' type='xmlChar *' info=' the local part of the name QName'/>
      <field name='nameURI' type='xmlChar *' info=' the URI part of the name QName'/>
      <field name='mode' type='xmlChar *' info=' the local part of the mode QName'/>
      <field name='modeURI' type='xmlChar *' info=' the URI part of the mode QName'/>
      <field name='content' type='xmlNodePtr' info=' the template replacement value'/>
      <field name='elem' type='xmlNodePtr' info=' the source element'/>
      <field name='inheritedNsNr' type='int' info=' number of inherited namespaces'/>
      <field name='inheritedNs' type='xmlNsPtr *' info=' inherited non-excluded namespaces Profiling informations'/>
      <field name='nbCalls' type='int' info=' the number of time the template was called'/>
      <field name='time' type='unsigned long' info=' the time spent in this template'/>
    </struct>
    <typedef name='xsltTemplatePtr' file='xsltInternals' type='xsltTemplate *'/>
    <struct name='xsltTransformContext' file='xsltInternals' type='struct _xsltTransformContext'>
      <field name='style' type='xsltStylesheetPtr' info=' the stylesheet used'/>
      <field name='type' type='xsltOutputType' info=' the type of output'/>
      <field name='templ' type='xsltTemplatePtr' info=' the current template'/>
      <field name='templNr' type='int' info=' Nb of templates in the stack'/>
      <field name='templMax' type='int' info=' Size of the templtes stack'/>
      <field name='templTab' type='xsltTemplatePtr *' info=' the template stack'/>
      <field name='vars' type='xsltStackElemPtr' info=' the current variable list'/>
      <field name='varsNr' type='int' info=' Nb of variable list in the stack'/>
      <field name='varsMax' type='int' info=' Size of the variable list stack'/>
      <field name='varsTab' type='xsltStackElemPtr *' info=' the variable list stack'/>
      <field name='varsBase' type='int' info='* Extensions
*'/>
      <field name='extFunctions' type='xmlHashTablePtr' info=' the extension functions'/>
      <field name='extElements' type='xmlHashTablePtr' info=' the extension elements'/>
      <field name='extInfos' type='xmlHashTablePtr' info=' the extension data'/>
      <field name='mode' type='const xmlChar *' info=' the current mode'/>
      <field name='modeURI' type='const xmlChar *' info=' the current mode URI'/>
      <field name='docList' type='xsltDocumentPtr' info=' the document list'/>
      <field name='document' type='xsltDocumentPtr' info=' the current document'/>
      <field name='node' type='xmlNodePtr' info=' the current node being processed'/>
      <field name='nodeList' type='xmlNodeSetPtr' info=' the current node list xmlNodePtr current;			the node'/>
      <field name='output' type='xmlDocPtr' info=' the resulting document'/>
      <field name='insert' type='xmlNodePtr' info=' the insertion node'/>
      <field name='xpathCtxt' type='xmlXPathContextPtr' info=' the XPath context'/>
      <field name='state' type='xsltTransformState' info='* Global variables
*'/>
      <field name='globalVars' type='xmlHashTablePtr' info=' the global variables and params'/>
      <field name='inst' type='xmlNodePtr' info=' the instruction in the stylesheet'/>
      <field name='xinclude' type='int' info=' should XInclude be processed'/>
      <field name='outputFile' type='const char *' info=' the output URI if known'/>
      <field name='profile' type='int' info=' is this run profiled'/>
      <field name='prof' type='long' info=' the current profiled value'/>
      <field name='profNr' type='int' info=' Nb of templates in the stack'/>
      <field name='profMax' type='int' info=' Size of the templtaes stack'/>
      <field name='profTab' type='long *' info=' the profile template stack'/>
      <field name='_private' type='void *' info=' user defined data'/>
      <field name='extrasNr' type='int' info=' the number of extras used'/>
      <field name='extrasMax' type='int' info=' the number of extras allocated'/>
      <field name='extras' type='xsltRuntimeExtraPtr' info=' extra per runtime informations'/>
      <field name='styleList' type='xsltDocumentPtr' info=' the stylesheet docs list'/>
      <field name='sec' type='void *' info=' the security preferences if any'/>
      <field name='error' type='xmlGenericErrorFunc' info=' a specific error handler'/>
      <field name='errctx' type='void *' info=' context for the error handler'/>
      <field name='sortfunc' type='xsltSortFunc' info='* handling of temporary Result Value Tree
*'/>
      <field name='tmpRVT' type='xmlDocPtr' info=' list of RVT without persistance'/>
      <field name='persistRVT' type='xmlDocPtr' info=' list of persistant RVTs'/>
      <field name='ctxtflags' type='int' info='* Speed optimization when coalescing text nodes
*'/>
      <field name='lasttext' type='const xmlChar *' info=' last text node content'/>
      <field name='lasttsize' type='unsigned int' info=' last text node size'/>
      <field name='lasttuse' type='unsigned int' info=' last text node use'/>
    </struct>
    <typedef name='xsltTransformContextPtr' file='xsltInternals' type='xsltTransformContext *'/>
    <typedef name='xsltTransformState' file='xsltInternals' type='enum'/>
    <variable name='xslDebugStatus' file='xsltutils' type='int'/>
    <variable name='xsltEngineVersion' file='xslt' type='const char *'/>
    <variable name='xsltExtMarker' file='preproc' type='const xmlChar *'/>
    <variable name='xsltGenericDebug' file='xsltutils' type='xmlGenericErrorFunc'/>
    <variable name='xsltGenericDebugContext' file='xsltutils' type='void *'/>
    <variable name='xsltGenericError' file='xsltutils' type='xmlGenericErrorFunc'/>
    <variable name='xsltGenericErrorContext' file='xsltutils' type='void *'/>
    <variable name='xsltLibxmlVersion' file='xslt' type='const int'/>
    <variable name='xsltLibxsltVersion' file='xslt' type='const int'/>
    <variable name='xsltMaxDepth' file='xslt' type='int'/>
    <function name='xslAddCall' file='xsltutils'>
      <info>Add template &quot;call&quot; to call stack</info>
      <return type='int' info=': 1 on sucess 0 otherwise an error may be printed if WITH_XSLT_DEBUG_BREAKPOINTS is defined'/>
      <arg name='templ' type='xsltTemplatePtr' info='current template being applied'/>
      <arg name='source' type='xmlNodePtr' info='the source node being processed'/>
    </function>
    <function name='xslDropCall' file='xsltutils'>
      <info>Drop the topmost item off the call stack</info>
      <return type='void'/>
    </function>
    <function name='xslHandleDebugger' file='transform'>
      <info>If either cur or node are a breakpoint, or xslDebugStatus in state where debugging must occcur at this time then transfer control to the xslDebugBreak function</info>
      <return type='void'/>
      <arg name='cur' type='xmlNodePtr' info='source node being executed'/>
      <arg name='node' type='xmlNodePtr' info='data node being processed'/>
      <arg name='templ' type='xsltTemplatePtr' info='temlate that applies to node'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='the xslt transform context'/>
    </function>
    <functype name='xsltAddCallCallback' file='xsltutils'>
      <info></info>
      <return type='int' info=''/>
      <arg name='templ' type='xsltTemplatePtr' info=''/>
      <arg name='source' type='xmlNodePtr' info=''/>
    </functype>
    <function name='xsltAddKey' file='keys'>
      <info>add a key definition to a stylesheet</info>
      <return type='int' info='0 in case of success, and -1 in case of failure.'/>
      <arg name='style' type='xsltStylesheetPtr' info='an XSLT stylesheet'/>
      <arg name='name' type='const xmlChar *' info='the key name or NULL'/>
      <arg name='nameURI' type='const xmlChar *' info='the name URI or NULL'/>
      <arg name='match' type='const xmlChar *' info='the match value'/>
      <arg name='use' type='const xmlChar *' info='the use value'/>
      <arg name='inst' type='xmlNodePtr' info='the key instruction'/>
    </function>
    <function name='xsltAddStackElemList' file='variables'>
      <info>add the new element list at this level of the stack.</info>
      <return type='int' info='0 in case of success, -1 in case of failure.'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='xn XSLT transformation context'/>
      <arg name='elems' type='xsltStackElemPtr' info='a stack element list'/>
    </function>
    <function name='xsltAddTemplate' file='pattern'>
      <info>Register the XSLT pattern associated to @cur</info>
      <return type='int' info='-1 in case of error, 0 otherwise'/>
      <arg name='style' type='xsltStylesheetPtr' info='an XSLT stylesheet'/>
      <arg name='cur' type='xsltTemplatePtr' info='an XSLT template'/>
      <arg name='mode' type='const xmlChar *' info='the mode name or NULL'/>
      <arg name='modeURI' type='const xmlChar *' info='the mode URI or NULL'/>
    </function>
    <function name='xsltAllocateExtra' file='xsltInternals'>
      <info>Allocate an extra runtime information slot statically while compiling the stylesheet and return its number</info>
      <return type='int' info='the number of the slot'/>
      <arg name='style' type='xsltStylesheetPtr' info='an XSLT stylesheet'/>
    </function>
    <function name='xsltAllocateExtraCtxt' file='xsltInternals'>
      <info>Allocate an extra runtime information slot at run-time and return its number This make sure there is a slot ready in the transformation context</info>
      <return type='int' info='the number of the slot'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context'/>
    </function>
    <function name='xsltApplyAttributeSet' file='attributes'>
      <info>Apply the xsl:use-attribute-sets</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='the XSLT stylesheet'/>
      <arg name='node' type='xmlNodePtr' info='the node in the source tree.'/>
      <arg name='inst' type='xmlNodePtr' info='the xslt attribute node'/>
      <arg name='attributes' type='xmlChar *' info='the set list.'/>
    </function>
    <function name='xsltApplyImports' file='transform'>
      <info>Process the xslt apply-imports node on the source node</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a XSLT process context'/>
      <arg name='node' type='xmlNodePtr' info='the node in the source tree.'/>
      <arg name='inst' type='xmlNodePtr' info='the xslt apply-imports node'/>
      <arg name='comp' type='xsltStylePreCompPtr' info='precomputed information'/>
    </function>
    <function name='xsltApplyOneTemplate' file='transform'>
      <info>Process the apply-templates node on the source node, if params are passed they are pushed on the variable stack but not popped, it&apos;s left to the caller to handle them back (they may be reused).</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a XSLT process context'/>
      <arg name='node' type='xmlNodePtr' info='the node in the source tree.'/>
      <arg name='list' type='xmlNodePtr' info='the template replacement nodelist'/>
      <arg name='templ' type='xsltTemplatePtr' info='if is this a real template processing, the template processed'/>
      <arg name='params' type='xsltStackElemPtr' info='a set of parameters for the template or NULL'/>
    </function>
    <function name='xsltApplyStripSpaces' file='transform'>
      <info>Strip the unwanted ignorable spaces from the input tree</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a XSLT process context'/>
      <arg name='node' type='xmlNodePtr' info='the root of the XML tree'/>
    </function>
    <function name='xsltApplyStylesheet' file='transform'>
      <info>Apply the stylesheet to the document NOTE: This may lead to a non-wellformed output XML wise !</info>
      <return type='xmlDocPtr' info='the result document or NULL in case of error'/>
      <arg name='style' type='xsltStylesheetPtr' info='a parsed XSLT stylesheet'/>
      <arg name='doc' type='xmlDocPtr' info='a parsed XML document'/>
      <arg name='params' type='const char **' info='a NULL terminated arry of parameters names/values tuples'/>
    </function>
    <function name='xsltApplyStylesheetUser' file='transform'>
      <info>Apply the stylesheet to the document and allow the user to provide its own transformation context.</info>
      <return type='xmlDocPtr' info='the result document or NULL in case of error'/>
      <arg name='style' type='xsltStylesheetPtr' info='a parsed XSLT stylesheet'/>
      <arg name='doc' type='xmlDocPtr' info='a parsed XML document'/>
      <arg name='params' type='const char **' info='a NULL terminated arry of parameters names/values tuples'/>
      <arg name='output' type='const char *' info='the targetted output'/>
      <arg name='profile' type='FILE *' info='profile FILE * output or NULL'/>
      <arg name='userCtxt' type='xsltTransformContextPtr' info='user provided transform context'/>
    </function>
    <function name='xsltApplyTemplates' file='transform'>
      <info>Process the apply-templates node on the source node</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a XSLT process context'/>
      <arg name='node' type='xmlNodePtr' info='the node in the source tree.'/>
      <arg name='inst' type='xmlNodePtr' info='the apply-templates node'/>
      <arg name='comp' type='xsltStylePreCompPtr' info='precomputed information'/>
    </function>
    <function name='xsltAttrListTemplateProcess' file='templates'>
      <info>Do a copy of an attribute list with attribute template processing</info>
      <return type='xmlAttrPtr' info='a new xmlAttrPtr, or NULL in case of error.'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='the XSLT transformation context'/>
      <arg name='target' type='xmlNodePtr' info='the element where the attributes will be grafted'/>
      <arg name='cur' type='xmlAttrPtr' info='the first attribute'/>
    </function>
    <function name='xsltAttrTemplateProcess' file='templates'>
      <info>Process the given attribute and return the new processed copy.</info>
      <return type='xmlAttrPtr' info='the attribute replacement.'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='the XSLT transformation context'/>
      <arg name='target' type='xmlNodePtr' info='the result node'/>
      <arg name='cur' type='xmlAttrPtr' info='the attribute template node'/>
    </function>
    <function name='xsltAttrTemplateValueProcess' file='templates'>
      <info>Process the given node and return the new string value.</info>
      <return type='xmlChar *' info='the computed string value or NULL, must be deallocated by the caller.'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='the XSLT transformation context'/>
      <arg name='str' type='const xmlChar *' info='the attribute template node value'/>
    </function>
    <function name='xsltAttrTemplateValueProcessNode' file='templates'>
      <info>Process the given string, allowing to pass a namespace mapping context and return the new string value.</info>
      <return type='xmlChar *' info='the computed string value or NULL, must be deallocated by the caller.'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='the XSLT transformation context'/>
      <arg name='str' type='const xmlChar *' info='the attribute template node value'/>
      <arg name='node' type='xmlNodePtr' info='the node hosting the attribute'/>
    </function>
    <function name='xsltAttribute' file='transform'>
      <info>Process the xslt attribute node on the source node</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a XSLT process context'/>
      <arg name='node' type='xmlNodePtr' info='the node in the source tree.'/>
      <arg name='inst' type='xmlNodePtr' info='the xslt attribute node'/>
      <arg name='comp' type='xsltStylePreCompPtr' info='precomputed information'/>
    </function>
    <function name='xsltCalibrateAdjust' file='xsltutils'>
      <info>Used for to correct the calibration for xsltTimestamp()</info>
      <return type='void'/>
      <arg name='delta' type='long' info='a negative dealy value found'/>
    </function>
    <function name='xsltCallTemplate' file='transform'>
      <info>Process the xslt call-template node on the source node</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a XSLT process context'/>
      <arg name='node' type='xmlNodePtr' info='the node in the source tree.'/>
      <arg name='inst' type='xmlNodePtr' info='the xslt call-template node'/>
      <arg name='comp' type='xsltStylePreCompPtr' info='precomputed information'/>
    </function>
    <function name='xsltCheckExtPrefix' file='extensions'>
      <info>Check if the given prefix is one of the declared extensions</info>
      <return type='int' info='1 if this is an extension, 0 otherwise'/>
      <arg name='style' type='xsltStylesheetPtr' info='the stylesheet'/>
      <arg name='prefix' type='const xmlChar *' info='the namespace prefix (possibly NULL)'/>
    </function>
    <function name='xsltCheckRead' file='security'>
      <info>Check if the resource is allowed to be read</info>
      <return type='int' info='1 if read is allowed, 0 if not and -1 in case or error.'/>
      <arg name='sec' type='xsltSecurityPrefsPtr' info='the security options'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context'/>
      <arg name='URL' type='const xmlChar *' info='the resource to be read'/>
    </function>
    <function name='xsltCheckWrite' file='security'>
      <info>Check if the resource is allowed to be written, if necessary makes some preliminary work like creating directories</info>
      <return type='int' info='1 if write is allowed, 0 if not and -1 in case or error.'/>
      <arg name='sec' type='xsltSecurityPrefsPtr' info='the security options'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context'/>
      <arg name='URL' type='const xmlChar *' info='the resource to be written'/>
    </function>
    <function name='xsltChoose' file='transform'>
      <info>Process the xslt choose node on the source node</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a XSLT process context'/>
      <arg name='node' type='xmlNodePtr' info='the node in the source tree.'/>
      <arg name='inst' type='xmlNodePtr' info='the xslt choose node'/>
      <arg name='comp' type='xsltStylePreCompPtr' info='precomputed information'/>
    </function>
    <function name='xsltCleanupGlobals' file='xslt'>
      <info>Unregister all global variables set up by the XSLT library</info>
      <return type='void'/>
    </function>
    <function name='xsltCleanupTemplates' file='pattern'>
      <info>Cleanup the state of the templates used by the stylesheet and the ones it imports.</info>
      <return type='void'/>
      <arg name='style' type='xsltStylesheetPtr' info='an XSLT stylesheet'/>
    </function>
    <function name='xsltComment' file='transform'>
      <info>Process the xslt comment node on the source node</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a XSLT process context'/>
      <arg name='node' type='xmlNodePtr' info='the node in the source tree.'/>
      <arg name='inst' type='xmlNodePtr' info='the xslt comment node'/>
      <arg name='comp' type='xsltStylePreCompPtr' info='precomputed information'/>
    </function>
    <function name='xsltCompilePattern' file='pattern'>
      <info>Compile the XSLT pattern and generates a list of precompiled form suitable for fast matching.  [1] Pattern ::= LocationPathPattern | Pattern &apos;|&apos; LocationPathPattern</info>
      <return type='xsltCompMatchPtr' info='the generated pattern list or NULL in case of failure'/>
      <arg name='pattern' type='const xmlChar *' info='an XSLT pattern'/>
      <arg name='doc' type='xmlDocPtr' info='the containing document'/>
      <arg name='node' type='xmlNodePtr' info='the containing element'/>
      <arg name='style' type='xsltStylesheetPtr' info='the stylesheet'/>
      <arg name='runtime' type='xsltTransformContextPtr' info='the transformation context, if done at run-time'/>
    </function>
    <function name='xsltComputeSortResult' file='xsltutils'>
      <info>reorder the current node list accordingly to the set of sorting requirement provided by the array of nodes.</info>
      <return type='xmlXPathObjectPtr *' info='a ordered XPath nodeset or NULL in case of error.'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a XSLT process context'/>
      <arg name='sort' type='xmlNodePtr' info='node list'/>
    </function>
    <function name='xsltCopy' file='transform'>
      <info>Process the xslt copy node on the source node</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a XSLT process context'/>
      <arg name='node' type='xmlNodePtr' info='the node in the source tree.'/>
      <arg name='inst' type='xmlNodePtr' info='the xslt copy node'/>
      <arg name='comp' type='xsltStylePreCompPtr' info='precomputed information'/>
    </function>
    <function name='xsltCopyNamespace' file='namespaces'>
      <info>Do a copy of an namespace node. If @node is non-NULL the new namespaces are added automatically. This handles namespaces aliases</info>
      <return type='xmlNsPtr' info='a new xmlNsPtr, or NULL in case of error.'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a transformation context'/>
      <arg name='node' type='xmlNodePtr' info='the target node'/>
      <arg name='cur' type='xmlNsPtr' info='the namespace node'/>
    </function>
    <function name='xsltCopyNamespaceList' file='namespaces'>
      <info>Do a copy of an namespace list. If @node is non-NULL the new namespaces are added automatically. This handles namespaces aliases</info>
      <return type='xmlNsPtr' info='a new xmlNsPtr, or NULL in case of error.'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a transformation context'/>
      <arg name='node' type='xmlNodePtr' info='the target node'/>
      <arg name='cur' type='xmlNsPtr' info='the first namespace'/>
    </function>
    <function name='xsltCopyOf' file='transform'>
      <info>Process the xslt copy-of node on the source node</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a XSLT process context'/>
      <arg name='node' type='xmlNodePtr' info='the node in the source tree.'/>
      <arg name='inst' type='xmlNodePtr' info='the xslt copy-of node'/>
      <arg name='comp' type='xsltStylePreCompPtr' info='precomputed information'/>
    </function>
    <function name='xsltCopyTextString' file='transform'>
      <info>Create a text node</info>
      <return type='xmlNodePtr' info='a new xmlNodePtr, or NULL in case of error.'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a XSLT process context'/>
      <arg name='target' type='xmlNodePtr' info='the element where the text will be attached'/>
      <arg name='string' type='const xmlChar *' info='the text string'/>
      <arg name='noescape' type='int' info='should disable-escaping be activated for this text node.'/>
    </function>
    <function name='xsltCreateRVT' file='xsltInternals'>
      <info>Create a result value tree</info>
      <return type='xmlDocPtr' info='the result value tree or NULL in case of error'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context'/>
    </function>
    <function name='xsltDebug' file='extra'>
      <info>Process an debug node</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT processing context'/>
      <arg name='node' type='xmlNodePtr' info='The current node'/>
      <arg name='inst' type='xmlNodePtr' info='the instruction in the stylesheet'/>
      <arg name='comp' type='xsltStylePreCompPtr' info='precomputed informations'/>
    </function>
    <function name='xsltDebugDumpExtensions' file='extensions'>
      <info>Dumps a list of the registered XSLT extension functions and elements</info>
      <return type='void'/>
      <arg name='output' type='FILE *' info='the FILE * for the output, if NULL stdout is used'/>
    </function>
    <function name='xsltDecimalFormatGetByName' file='xsltInternals'>
      <info>Find decimal-format by name</info>
      <return type='xsltDecimalFormatPtr' info='the xsltDecimalFormatPtr'/>
      <arg name='sheet' type='xsltStylesheetPtr' info='the XSLT stylesheet'/>
      <arg name='name' type='xmlChar *' info='the decimal-format name to find'/>
    </function>
    <function name='xsltDefaultSortFunction' file='xsltutils'>
      <info>reorder the current node list accordingly to the set of sorting requirement provided by the arry of nodes.</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a XSLT process context'/>
      <arg name='sorts' type='xmlNodePtr *' info='array of sort nodes'/>
      <arg name='nbsorts' type='int' info='the number of sorts in the array'/>
    </function>
    <function name='xsltDoSortFunction' file='xsltutils'>
      <info>reorder the current node list accordingly to the set of sorting requirement provided by the arry of nodes. This is a wrapper function, the actual function used is specified using xsltSetCtxtSortFunc() to set the context specific sort function, or xsltSetSortFunc() to set the global sort function. If a sort function is set on the context, this will get called. Otherwise the global sort function is called.</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a XSLT process context'/>
      <arg name='sorts' type='xmlNodePtr *' info='array of sort nodes'/>
      <arg name='nbsorts' type='int' info='the number of sorts in the array'/>
    </function>
    <function name='xsltDocumentComp' file='preproc'>
      <info>Pre process an XSLT-1.1 document element</info>
      <return type='xsltElemPreCompPtr' info='a precompiled data structure for the element'/>
      <arg name='style' type='xsltStylesheetPtr' info='the XSLT stylesheet'/>
      <arg name='inst' type='xmlNodePtr' info='the instruction in the stylesheet'/>
      <arg name='function' type='xsltTransformFunction' info='unused'/>
    </function>
    <function name='xsltDocumentElem' file='transform'>
      <info>Process an EXSLT/XSLT-1.1 document element</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT processing context'/>
      <arg name='node' type='xmlNodePtr' info='The current node'/>
      <arg name='inst' type='xmlNodePtr' info='the instruction in the stylesheet'/>
      <arg name='comp' type='xsltStylePreCompPtr' info='precomputed information'/>
    </function>
    <function name='xsltDocumentFunction' file='functions'>
      <info>Implement the document() XSLT function node-set document(object, node-set?)</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context'/>
      <arg name='nargs' type='int' info='the number of arguments'/>
    </function>
    <function name='xsltDocumentSortFunction' file='xsltutils'>
      <info>reorder the current node list @list accordingly to the document order</info>
      <return type='void'/>
      <arg name='list' type='xmlNodeSetPtr' info='the node set'/>
    </function>
    <functype name='xsltDropCallCallback' file='xsltutils'>
      <info></info>
      <return type='void'/>
    </functype>
    <functype name='xsltElemPreCompDeallocator' file='xsltInternals'>
      <info>Deallocates an #xsltElemPreComp structure.</info>
      <return type='void'/>
      <arg name='comp' type='xsltElemPreCompPtr' info='the #xsltElemPreComp to free up'/>
    </functype>
    <function name='xsltElement' file='transform'>
      <info>Process the xslt element node on the source node</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a XSLT process context'/>
      <arg name='node' type='xmlNodePtr' info='the node in the source tree.'/>
      <arg name='inst' type='xmlNodePtr' info='the xslt element node'/>
      <arg name='comp' type='xsltStylePreCompPtr' info='precomputed information'/>
    </function>
    <function name='xsltElementAvailableFunction' file='functions'>
      <info>Implement the element-available() XSLT function boolean element-available(string)</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context'/>
      <arg name='nargs' type='int' info='the number of arguments'/>
    </function>
    <function name='xsltEvalAttrValueTemplate' file='templates'>
      <info>Evaluate a attribute value template, i.e. the attribute value can contain expressions contained in curly braces ({}) and those are substituted by they computed value.</info>
      <return type='xmlChar *' info='the computed string value or NULL, must be deallocated by the caller.'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='the XSLT transformation context'/>
      <arg name='node' type='xmlNodePtr' info='the stylesheet node'/>
      <arg name='name' type='const xmlChar *' info='the attribute QName'/>
      <arg name='ns' type='const xmlChar *' info='the attribute namespace URI'/>
    </function>
    <function name='xsltEvalGlobalVariables' file='variables'>
      <info>Evaluate the global variables of a stylesheet. This need to be done on parsed stylesheets before starting to apply transformations</info>
      <return type='int' info='0 in case of success, -1 in case of error'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='the XSLT transformation context'/>
    </function>
    <function name='xsltEvalOneUserParam' file='variables'>
      <info>This is normally called from xsltEvalUserParams to process a single parameter from a list of parameters.  The @value is evaluated as an XPath expression and the result is stored in the context&apos;s global variable/parameter hash table.  To have a parameter treated literally (not as an XPath expression) use xsltQuoteUserParams (or xsltQuoteOneUserParam).  For more details see description of xsltProcessOneUserParamInternal.</info>
      <return type='int' info='0 in case of success, -1 in case of error.'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='the XSLT transformation context'/>
      <arg name='name' type='const xmlChar *' info='a null terminated string giving the name of the parameter'/>
      <arg name='value' type='const xmlChar *' info='a null terminated string giving the XPath expression to be evaluated'/>
    </function>
    <function name='xsltEvalStaticAttrValueTemplate' file='templates'>
      <info>Check if an attribute value template has a static value, i.e. the attribute value does not contain expressions contained in curly braces ({})</info>
      <return type='xmlChar *' info='the static string value or NULL, must be deallocated by the caller.'/>
      <arg name='style' type='xsltStylesheetPtr' info='the XSLT stylesheet'/>
      <arg name='node' type='xmlNodePtr' info='the stylesheet node'/>
      <arg name='name' type='const xmlChar *' info='the attribute Name'/>
      <arg name='ns' type='const xmlChar *' info='the attribute namespace URI'/>
      <arg name='found' type='int *' info='indicator whether the attribute is present'/>
    </function>
    <function name='xsltEvalTemplateString' file='templates'>
      <info>Evaluate a template string value, i.e. the parent list is interpreter as template content and the resulting tree string value is returned This is needed for example by xsl:comment and xsl:processing-instruction</info>
      <return type='xmlChar *' info='the computed string value or NULL, must be deallocated by the caller.'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='the XSLT transformation context'/>
      <arg name='node' type='xmlNodePtr' info='the stylesheet node'/>
      <arg name='parent' type='xmlNodePtr' info='the content parent'/>
    </function>
    <function name='xsltEvalUserParams' file='variables'>
      <info>Evaluate the global variables of a stylesheet. This needs to be done on parsed stylesheets before starting to apply transformations. Each of the parameters is evaluated as an XPath expression and stored in the global variables/parameter hash table.  If you want your parameter used literally, use xsltQuoteUserParams.</info>
      <return type='int' info='0 in case of success, -1 in case of error'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='the XSLT transformation context'/>
      <arg name='params' type='const char **' info='a NULL terminated array of parameters name/value tuples'/>
    </function>
    <function name='xsltEvalXPathPredicate' file='templates'>
      <info>Process the expression using XPath and evaluate the result as an XPath predicate</info>
      <return type='int' info='1 is the predicate was true, 0 otherwise'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='the XSLT transformation context'/>
      <arg name='comp' type='xmlXPathCompExprPtr' info='the XPath compiled expression'/>
      <arg name='nsList' type='xmlNsPtr *' info='the namespaces in scope'/>
      <arg name='nsNr' type='int' info='the number of namespaces in scope'/>
    </function>
    <function name='xsltEvalXPathString' file='templates'>
      <info>Process the expression using XPath and get a string</info>
      <return type='xmlChar *' info='the computed string value or NULL, must be deallocated by the caller.'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='the XSLT transformation context'/>
      <arg name='comp' type='xmlXPathCompExprPtr' info='the compiled XPath expression'/>
    </function>
    <function name='xsltEvalXPathStringNs' file='templates'>
      <info>Process the expression using XPath, allowing to pass a namespace mapping context and get a string</info>
      <return type='xmlChar *' info='the computed string value or NULL, must be deallocated by the caller.'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='the XSLT transformation context'/>
      <arg name='comp' type='xmlXPathCompExprPtr' info='the compiled XPath expression'/>
      <arg name='nsNr' type='int' info='the number of namespaces in the list'/>
      <arg name='nsList' type='xmlNsPtr *' info='the list of in-scope namespaces to use'/>
    </function>
    <function name='xsltExtElementLookup' file='extensions'>
      <info>Looks up an extension element. @ctxt can be NULL to search only in module elements.</info>
      <return type='xsltTransformFunction' info='the element callback or NULL if not found'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT process context'/>
      <arg name='name' type='const xmlChar *' info='the element name'/>
      <arg name='URI' type='const xmlChar *' info='the element namespace URI'/>
    </function>
    <function name='xsltExtFunctionLookup' file='extensions'>
      <info></info>
      <return type='xmlXPathFunction' info=''/>
      <arg name='ctxt' type='xsltTransformContextPtr' info=''/>
      <arg name='name' type='const xmlChar *' info=''/>
      <arg name='URI' type='const xmlChar *' info=''/>
    </function>
    <functype name='xsltExtInitFunction' file='extensions'>
      <info>A function called at initialization time of an XSLT extension module.</info>
      <return type='void *' info='a pointer to the module specific data for this transformation.'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context'/>
      <arg name='URI' type='const xmlChar *' info='the namespace URI for the extension'/>
    </functype>
    <function name='xsltExtModuleElementLookup' file='extensions'>
      <info>Looks up an extension module element</info>
      <return type='xsltTransformFunction' info='the callback function if found, NULL otherwise.'/>
      <arg name='name' type='const xmlChar *' info='the element name'/>
      <arg name='URI' type='const xmlChar *' info='the element namespace URI'/>
    </function>
    <function name='xsltExtModuleElementPreComputeLookup' file='extensions'>
      <info>Looks up an extension module element pre-computation function</info>
      <return type='xsltPreComputeFunction' info='the callback function if found, NULL otherwise.'/>
      <arg name='name' type='const xmlChar *' info='the element name'/>
      <arg name='URI' type='const xmlChar *' info='the element namespace URI'/>
    </function>
    <function name='xsltExtModuleFunctionLookup' file='extensions'>
      <info>Looks up an extension module function</info>
      <return type='xmlXPathFunction' info='the function if found, NULL otherwise.'/>
      <arg name='name' type='const xmlChar *' info='the function name'/>
      <arg name='URI' type='const xmlChar *' info='the function namespace URI'/>
    </function>
    <function name='xsltExtModuleTopLevelLookup' file='extensions'>
      <info>Looks up an extension module top-level element</info>
      <return type='xsltTopLevelFunction' info='the callback function if found, NULL otherwise.'/>
      <arg name='name' type='const xmlChar *' info='the top-level element name'/>
      <arg name='URI' type='const xmlChar *' info='the top-level element namespace URI'/>
    </function>
    <functype name='xsltExtShutdownFunction' file='extensions'>
      <info>A function called at shutdown time of an XSLT extension module.</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context'/>
      <arg name='URI' type='const xmlChar *' info='the namespace URI for the extension'/>
      <arg name='data' type='void *' info='the data associated to this module'/>
    </functype>
    <function name='xsltFindDocument' file='documents'>
      <info>Try to find a document within the XSLT transformation context</info>
      <return type='xsltDocumentPtr' info='the desired xsltDocumentPtr or NULL in case of error'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context'/>
      <arg name='doc' type='xmlDocPtr' info='a parsed XML document'/>
    </function>
    <function name='xsltFindElemSpaceHandling' file='imports'>
      <info>Find strip-space or preserve-space informations for an element respect the import precedence or the wildcards</info>
      <return type='int' info='1 if space should be stripped, 0 if not, and 2 if everything should be CDTATA wrapped.'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context'/>
      <arg name='node' type='xmlNodePtr' info='an XML node'/>
    </function>
    <function name='xsltFindTemplate' file='imports'>
      <info>Finds the named template, apply import precedence rule.</info>
      <return type='xsltTemplatePtr' info='the xsltTemplatePtr or NULL if not found'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context'/>
      <arg name='name' type='const xmlChar *' info='the template name'/>
      <arg name='nameURI' type='const xmlChar *' info='the template name URI'/>
    </function>
    <function name='xsltForEach' file='transform'>
      <info>Process the xslt for-each node on the source node</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a XSLT process context'/>
      <arg name='node' type='xmlNodePtr' info='the node in the source tree.'/>
      <arg name='inst' type='xmlNodePtr' info='the xslt for-each node'/>
      <arg name='comp' type='xsltStylePreCompPtr' info='precomputed information'/>
    </function>
    <function name='xsltFormatNumberConversion' file='xsltInternals'>
      <info>format-number() uses the JDK 1.1 DecimalFormat class:  http://java.sun.com/products/jdk/1.1/docs/api/java.text.DecimalFormat.html  Structure:  pattern    := subpattern{;subpattern} subpattern := {prefix}integer{.fraction}{suffix} prefix     := &apos;\\u0000&apos;..&apos;\\uFFFD&apos; - specialCharacters suffix     := &apos;\\u0000&apos;..&apos;\\uFFFD&apos; - specialCharacters integer    := &apos;#&apos;* &apos;0&apos;* &apos;0&apos; fraction   := &apos;0&apos;* &apos;#&apos;*  Notation: X*       0 or more instances of X (X | Y)  either X or Y. X..Y     any character from X up to Y, inclusive. S - T    characters in S, except those in T  Special Characters:  Symbol Meaning 0      a digit #      a digit, zero shows as absent .      placeholder for decimal separator ,      placeholder for grouping separator. ;      separates formats. -      default negative prefix. %      multiply by 100 and show as percentage ?      multiply by 1000 and show as per mille X      any other characters can be used in the prefix or suffix &apos;      used to quote special characters in a prefix or suffix.</info>
      <return type='xmlXPathError' info='a possible XPath error'/>
      <arg name='self' type='xsltDecimalFormatPtr' info='the decimal format'/>
      <arg name='format' type='xmlChar *' info='the format requested'/>
      <arg name='number' type='double' info='the value to format'/>
      <arg name='result' type='xmlChar **' info='the place to ouput the result'/>
    </function>
    <function name='xsltFormatNumberFunction' file='functions'>
      <info>Implement the format-number() XSLT function string format-number(number, string, string?)</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context'/>
      <arg name='nargs' type='int' info='the number of arguments'/>
    </function>
    <function name='xsltFreeAttributeSetsHashes' file='attributes'>
      <info>Free up the memory used by attribute sets</info>
      <return type='void'/>
      <arg name='style' type='xsltStylesheetPtr' info='an XSLT stylesheet'/>
    </function>
    <function name='xsltFreeCompMatchList' file='pattern'>
      <info>Free up the memory allocated by all the elements of @comp</info>
      <return type='void'/>
      <arg name='comp' type='xsltCompMatchPtr' info='an XSLT comp list'/>
    </function>
    <function name='xsltFreeCtxtExts' file='extensions'>
      <info>Free the XSLT extension data</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context'/>
    </function>
    <function name='xsltFreeDocumentKeys' file='keys'>
      <info>Free the keys associated to a document</info>
      <return type='void'/>
      <arg name='doc' type='xsltDocumentPtr' info='a XSLT document'/>
    </function>
    <function name='xsltFreeDocuments' file='documents'>
      <info>Free up all the space used by the loaded documents</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context'/>
    </function>
    <function name='xsltFreeExts' file='extensions'>
      <info>Free up the memory used by XSLT extensions in a stylesheet</info>
      <return type='void'/>
      <arg name='style' type='xsltStylesheetPtr' info='an XSLT stylesheet'/>
    </function>
    <function name='xsltFreeGlobalVariables' file='variables'>
      <info>Free up the data associated to the global variables its value.</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='the XSLT transformation context'/>
    </function>
    <function name='xsltFreeKeys' file='keys'>
      <info>Free up the memory used by XSLT keys in a stylesheet</info>
      <return type='void'/>
      <arg name='style' type='xsltStylesheetPtr' info='an XSLT stylesheet'/>
    </function>
    <function name='xsltFreeNamespaceAliasHashes' file='namespaces'>
      <info>Free up the memory used by namespaces aliases</info>
      <return type='void'/>
      <arg name='style' type='xsltStylesheetPtr' info='an XSLT stylesheet'/>
    </function>
    <function name='xsltFreeRVTs' file='xsltInternals'>
      <info>Free all the registered result value tree of the transformation</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context'/>
    </function>
    <function name='xsltFreeSecurityPrefs' file='security'>
      <info>Free up a security preference block</info>
      <return type='void'/>
      <arg name='sec' type='xsltSecurityPrefsPtr' info='the security block to free'/>
    </function>
    <function name='xsltFreeStackElemList' file='xsltInternals'>
      <info>Free up the memory allocated by @elem</info>
      <return type='void'/>
      <arg name='elem' type='xsltStackElemPtr' info='an XSLT stack element'/>
    </function>
    <function name='xsltFreeStyleDocuments' file='documents'>
      <info>Free up all the space used by the loaded documents</info>
      <return type='void'/>
      <arg name='style' type='xsltStylesheetPtr' info='an XSLT style sheet'/>
    </function>
    <function name='xsltFreeStylePreComps' file='preproc'>
      <info>Free up the memory allocated by all precomputed blocks</info>
      <return type='void'/>
      <arg name='style' type='xsltStylesheetPtr' info='an XSLT transformation context'/>
    </function>
    <function name='xsltFreeStylesheet' file='xsltInternals'>
      <info>Free up the memory allocated by @sheet</info>
      <return type='void'/>
      <arg name='sheet' type='xsltStylesheetPtr' info='an XSLT stylesheet'/>
    </function>
    <function name='xsltFreeTemplateHashes' file='pattern'>
      <info>Free up the memory used by xsltAddTemplate/xsltGetTemplate mechanism</info>
      <return type='void'/>
      <arg name='style' type='xsltStylesheetPtr' info='an XSLT stylesheet'/>
    </function>
    <function name='xsltFreeTransformContext' file='transform'>
      <info>Free up the memory allocated by @ctxt</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT parser context'/>
    </function>
    <function name='xsltFunctionAvailableFunction' file='functions'>
      <info>Implement the function-available() XSLT function boolean function-available(string)</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context'/>
      <arg name='nargs' type='int' info='the number of arguments'/>
    </function>
    <function name='xsltFunctionNodeSet' file='extra'>
      <info>Implement the node-set() XSLT function node-set node-set(result-tree)  This function is available in libxslt, saxon or xt namespace.</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context'/>
      <arg name='nargs' type='int' info='the number of arguments'/>
    </function>
    <function name='xsltGenerateIdFunction' file='functions'>
      <info>Implement the generate-id() XSLT function string generate-id(node-set?)</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context'/>
      <arg name='nargs' type='int' info='the number of arguments'/>
    </function>
    <function name='xsltGetDefaultSecurityPrefs' file='security'>
      <info>Get the default security preference application-wide</info>
      <return type='xsltSecurityPrefsPtr' info='the current xsltSecurityPrefsPtr in use or NULL if none'/>
    </function>
    <function name='xsltGetExtData' file='extensions'>
      <info>Retrieve the data associated to the extension module in this given transformation.</info>
      <return type='void *' info='the pointer or NULL if not present'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context'/>
      <arg name='URI' type='const xmlChar *' info='the URI associated to the exension module'/>
    </function>
    <function name='xsltGetExtInfo' file='extensions'>
      <info>looks up URI in extInfos of the stylesheet</info>
      <return type='xmlHashTablePtr' info='a pointer to the hash table if found, else NULL'/>
      <arg name='style' type='xsltStylesheetPtr' info='pointer to a stylesheet'/>
      <arg name='URI' type='const xmlChar *' info='the namespace URI desired'/>
    </function>
    <function name='xsltGetKey' file='keys'>
      <info>Lookup a key</info>
      <return type='xmlNodeSetPtr' info='the nodeset resulting from the query or NULL'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context'/>
      <arg name='name' type='const xmlChar *' info='the key name or NULL'/>
      <arg name='nameURI' type='const xmlChar *' info='the name URI or NULL'/>
      <arg name='value' type='const xmlChar *' info='the key value to look for'/>
    </function>
    <function name='xsltGetNamespace' file='namespaces'>
      <info>Find the right namespace value for this prefix, if needed create and add a new namespace decalaration on the node Handle namespace aliases</info>
      <return type='xmlNsPtr' info='the namespace node to use or NULL'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a transformation context'/>
      <arg name='cur' type='xmlNodePtr' info='the input node'/>
      <arg name='ns' type='xmlNsPtr' info='the namespace'/>
      <arg name='out' type='xmlNodePtr' info='the output node (or its parent)'/>
    </function>
    <function name='xsltGetNsProp' file='xsltutils'>
      <info>Similar to xmlGetNsProp() but with a slightly different semantic  Search and get the value of an attribute associated to a node This attribute has to be anchored in the namespace specified, or has no namespace and the element is in that namespace.  This does the entity substitution. This function looks in DTD attribute declaration for #FIXED or default declaration values unless DTD use has been turned off.</info>
      <return type='xmlChar *' info='the attribute value or NULL if not found. It&apos;s up to the caller to free the memory.'/>
      <arg name='node' type='xmlNodePtr' info='the node'/>
      <arg name='name' type='const xmlChar *' info='the attribute name'/>
      <arg name='nameSpace' type='const xmlChar *' info='the URI of the namespace'/>
    </function>
    <function name='xsltGetProfileInformation' file='xsltutils'>
      <info>This function should be called after the transformation completed to extract template processing profiling informations if availble. The informations are returned as an XML document tree like &lt;?xml version=&quot;1.0&quot;?&gt; &lt;profile&gt; &lt;template rank=&quot;1&quot; match=&quot;*&quot; name=&quot;&quot; mode=&quot;&quot; calls=&quot;6&quot; time=&quot;48&quot; average=&quot;8&quot;/&gt; &lt;template rank=&quot;2&quot; match=&quot;item2|item3&quot; name=&quot;&quot; mode=&quot;&quot; calls=&quot;10&quot; time=&quot;30&quot; average=&quot;3&quot;/&gt; &lt;template rank=&quot;3&quot; match=&quot;item1&quot; name=&quot;&quot; mode=&quot;&quot; calls=&quot;5&quot; time=&quot;17&quot; average=&quot;3&quot;/&gt; &lt;/profile&gt; The caller will need to free up the returned tree with xmlFreeDoc()</info>
      <return type='xmlDocPtr' info='the xmlDocPtr corresponding to the result or NULL if not available.'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a transformation context'/>
    </function>
    <function name='xsltGetQNameURI' file='xsltutils'>
      <info>This function analyzes @name, if the name contains a prefix, the function seaches the associated namespace in scope for it. It will also replace @name value with the NCName, the old value being freed. Errors in the prefix lookup are signalled by setting @name to NULL.  NOTE: the namespace returned is a pointer to the place where it is defined and hence has the same lifespan as the document holding it.</info>
      <return type='const xmlChar *' info='the namespace URI if there is a prefix, or NULL if @name is not prefixed.'/>
      <arg name='node' type='xmlNodePtr' info='the node holding the QName'/>
      <arg name='name' type='xmlChar **' info='pointer to the initial QName value'/>
    </function>
    <function name='xsltGetSecurityPrefs' file='security'>
      <info>Lookup the security option to get the callback checking function</info>
      <return type='xsltSecurityCheck' info='NULL if not found, the function otherwise'/>
      <arg name='sec' type='xsltSecurityPrefsPtr' info='the security block to update'/>
      <arg name='option' type='xsltSecurityOption' info='the option to lookup'/>
    </function>
    <function name='xsltGetSpecialNamespace' file='namespaces'>
      <info>Find the right namespace value for this URI, if needed create and add a new namespace decalaration on the node</info>
      <return type='xmlNsPtr' info='the namespace node to use or NULL'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a transformation context'/>
      <arg name='cur' type='xmlNodePtr' info='the input node'/>
      <arg name='URI' type='const xmlChar *' info='the namespace URI'/>
      <arg name='prefix' type='const xmlChar *' info='the suggested prefix'/>
      <arg name='out' type='xmlNodePtr' info='the output node (or its parent)'/>
    </function>
    <function name='xsltGetTemplate' file='pattern'>
      <info>Finds the template applying to this node, if @style is non-NULL it means one needs to look for the next imported template in scope.</info>
      <return type='xsltTemplatePtr' info='the xsltTemplatePtr or NULL if not found'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a XSLT process context'/>
      <arg name='node' type='xmlNodePtr' info='the node being processed'/>
      <arg name='style' type='xsltStylesheetPtr' info='the current style'/>
    </function>
    <function name='xsltGetUTF8Char' file='xsltutils'>
      <info>Read one UTF8 Char from @utf Function copied from libxml2 xmlGetUTF8Char() ... to discard ultimately and use the original API</info>
      <return type='int' info='the char value or -1 in case of error and update @len with the number of bytes used'/>
      <arg name='utf' type='const unsigned char *' info='a sequence of UTF-8 encoded bytes'/>
      <arg name='len' type='int *' info='a pointer to @bytes len'/>
    </function>
    <function name='xsltGetXIncludeDefault' file='transform'>
      <info>Provides the default state for XInclude processing</info>
      <return type='int' info='0 if there is no processing 1 otherwise'/>
    </function>
    <functype name='xsltHandleDebuggerCallback' file='xsltutils'>
      <info></info>
      <return type='void'/>
      <arg name='cur' type='xmlNodePtr' info=''/>
      <arg name='node' type='xmlNodePtr' info=''/>
      <arg name='templ' type='xsltTemplatePtr' info=''/>
      <arg name='ctxt' type='xsltTransformContextPtr' info=''/>
    </functype>
    <function name='xsltIf' file='transform'>
      <info>Process the xslt if node on the source node</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a XSLT process context'/>
      <arg name='node' type='xmlNodePtr' info='the node in the source tree.'/>
      <arg name='inst' type='xmlNodePtr' info='the xslt if node'/>
      <arg name='comp' type='xsltStylePreCompPtr' info='precomputed information'/>
    </function>
    <function name='xsltInitCtxtExts' file='extensions'>
      <info>Initialize the set of modules with registered stylesheet data</info>
      <return type='int' info='the number of modules initialized or -1 in case of error'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context'/>
    </function>
    <function name='xsltInitCtxtKeys' file='keys'>
      <info>Computes all the keys tables for the current input document. Should be done before global varibales are initialized.</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context'/>
      <arg name='doc' type='xsltDocumentPtr' info='an XSLT document'/>
    </function>
    <function name='xsltInitElemPreComp' file='extensions'>
      <info>Initializes an existing #xsltElemPreComp structure. This is usefull when extending an #xsltElemPreComp to store precomputed data. This function MUST be called on any extension element precomputed data struct.</info>
      <return type='void'/>
      <arg name='comp' type='xsltElemPreCompPtr' info='an #xsltElemPreComp (or generally a derived structure)'/>
      <arg name='style' type='xsltStylesheetPtr' info='the XSLT stylesheet'/>
      <arg name='inst' type='xmlNodePtr' info='the element node'/>
      <arg name='function' type='xsltTransformFunction' info='the transform function'/>
      <arg name='freeFunc' type='xsltElemPreCompDeallocator' info='the @comp deallocator'/>
    </function>
    <function name='xsltIsBlank' file='xsltInternals'>
      <info>Check if a string is ignorable</info>
      <return type='int' info='1 if the string is NULL or made of blanks chars, 0 otherwise'/>
      <arg name='str' type='xmlChar *' info='a string'/>
    </function>
    <function name='xsltKeyFunction' file='functions'>
      <info>Implement the key() XSLT function node-set key(string, object)</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context'/>
      <arg name='nargs' type='int' info='the number of arguments'/>
    </function>
    <function name='xsltLoadDocument' file='documents'>
      <info>Try to load a document (not a stylesheet) within the XSLT transformation context</info>
      <return type='xsltDocumentPtr' info='the new xsltDocumentPtr or NULL in case of error'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context'/>
      <arg name='URI' type='const xmlChar *' info='the computed URI of the document'/>
    </function>
    <function name='xsltLoadStyleDocument' file='documents'>
      <info>Try to load a stylesheet document within the XSLT transformation context</info>
      <return type='xsltDocumentPtr' info='the new xsltDocumentPtr or NULL in case of error'/>
      <arg name='style' type='xsltStylesheetPtr' info='an XSLT style sheet'/>
      <arg name='URI' type='const xmlChar *' info='the computed URI of the document'/>
    </function>
    <function name='xsltLoadStylesheetPI' file='xsltInternals'>
      <info>This function tries to locate the stylesheet PI in the given document If found, and if contained within the document, it will extract that subtree to build the stylesheet to process @doc (doc itself will be modified). If found but referencing an external document it will attempt to load it and generate a stylesheet from it. In both cases, the resulting stylesheet and the document need to be freed once the transformation is done.</info>
      <return type='xsltStylesheetPtr' info='a new XSLT stylesheet structure or NULL if not found.'/>
      <arg name='doc' type='xmlDocPtr' info='a document to process'/>
    </function>
    <function name='xsltMatchPattern' file='pattern'>
      <info></info>
      <return type='int' info=''/>
      <arg name='ctxt' type='xsltTransformContextPtr' info=''/>
      <arg name='node' type='xmlNodePtr' info=''/>
      <arg name='pattern' type='const xmlChar *' info=''/>
      <arg name='ctxtdoc' type='xmlDocPtr' info=''/>
      <arg name='ctxtnode' type='xmlNodePtr' info=''/>
    </function>
    <function name='xsltMessage' file='xsltutils'>
      <info>Process and xsl:message construct</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT processing context'/>
      <arg name='node' type='xmlNodePtr' info='The current node'/>
      <arg name='inst' type='xmlNodePtr' info='The node containing the message instruction'/>
    </function>
    <function name='xsltNamespaceAlias' file='namespaces'>
      <info>Read the stylesheet-prefix and result-prefix attributes, register them as well as the corresponding namespace.</info>
      <return type='void'/>
      <arg name='style' type='xsltStylesheetPtr' info='the XSLT stylesheet'/>
      <arg name='node' type='xmlNodePtr' info='the xsl:namespace-alias node'/>
    </function>
    <function name='xsltNeedElemSpaceHandling' file='imports'>
      <info>Checks whether that stylesheet requires white-space stripping</info>
      <return type='int' info='1 if space should be stripped, 0 if not'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context'/>
    </function>
    <function name='xsltNewDocument' file='documents'>
      <info>Register a new document, apply key computations</info>
      <return type='xsltDocumentPtr' info='a handler to the document'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context (or NULL)'/>
      <arg name='doc' type='xmlDocPtr' info='a parsed XML document'/>
    </function>
    <function name='xsltNewElemPreComp' file='extensions'>
      <info>Creates and initializes an #xsltElemPreComp</info>
      <return type='xsltElemPreCompPtr' info='the new and initialized #xsltElemPreComp'/>
      <arg name='style' type='xsltStylesheetPtr' info='the XSLT stylesheet'/>
      <arg name='inst' type='xmlNodePtr' info='the element node'/>
      <arg name='function' type='xsltTransformFunction' info='the transform function'/>
    </function>
    <function name='xsltNewSecurityPrefs' file='security'>
      <info>Create a new security preference block</info>
      <return type='xsltSecurityPrefsPtr' info='a pointer to the new block or NULL in case of error'/>
    </function>
    <function name='xsltNewStyleDocument' file='documents'>
      <info>Register a new document, apply key computations</info>
      <return type='xsltDocumentPtr' info='a handler to the document'/>
      <arg name='style' type='xsltStylesheetPtr' info='an XSLT style sheet'/>
      <arg name='doc' type='xmlDocPtr' info='a parsed XML document'/>
    </function>
    <function name='xsltNewStylesheet' file='xsltInternals'>
      <info>Create a new XSLT Stylesheet</info>
      <return type='xsltStylesheetPtr' info='the newly allocated xsltStylesheetPtr or NULL in case of error'/>
    </function>
    <function name='xsltNewTransformContext' file='transform'>
      <info>Create a new XSLT TransformContext</info>
      <return type='xsltTransformContextPtr' info='the newly allocated xsltTransformContextPtr or NULL in case of error'/>
      <arg name='style' type='xsltStylesheetPtr' info='a parsed XSLT stylesheet'/>
      <arg name='doc' type='xmlDocPtr' info='the input document'/>
    </function>
    <function name='xsltNextImport' file='imports'>
      <info>Find the next stylesheet in import precedence.</info>
      <return type='xsltStylesheetPtr' info='the next stylesheet or NULL if it was the last one'/>
      <arg name='cur' type='xsltStylesheetPtr' info='the current XSLT stylesheet'/>
    </function>
    <function name='xsltNormalizeCompSteps' file='pattern'>
      <info>This is a hashtable scanner function to normalize the compiled steps of an imported stylesheet.</info>
      <return type='void'/>
      <arg name='payload' type='void *' info='pointer to template hash table entry'/>
      <arg name='data' type='void *' info='pointer to the stylesheet'/>
      <arg name='name' type='const xmlChar *' info='template match name'/>
    </function>
    <function name='xsltNumber' file='transform'>
      <info>Process the xslt number node on the source node</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a XSLT process context'/>
      <arg name='node' type='xmlNodePtr' info='the node in the source tree.'/>
      <arg name='inst' type='xmlNodePtr' info='the xslt number node'/>
      <arg name='comp' type='xsltStylePreCompPtr' info='precomputed information'/>
    </function>
    <function name='xsltNumberFormat' file='xsltInternals'>
      <info>Convert one number.</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='the XSLT transformation context'/>
      <arg name='data' type='xsltNumberDataPtr' info='the formatting informations'/>
      <arg name='node' type='xmlNodePtr' info='the data to format'/>
    </function>
    <function name='xsltParseGlobalParam' file='variables'>
      <info>parse an XSLT transformation param declaration and record its value.</info>
      <return type='void'/>
      <arg name='style' type='xsltStylesheetPtr' info='the XSLT stylesheet'/>
      <arg name='cur' type='xmlNodePtr' info='the &quot;param&quot; element'/>
    </function>
    <function name='xsltParseGlobalVariable' file='variables'>
      <info>parse an XSLT transformation variable declaration and record its value.</info>
      <return type='void'/>
      <arg name='style' type='xsltStylesheetPtr' info='the XSLT stylesheet'/>
      <arg name='cur' type='xmlNodePtr' info='the &quot;variable&quot; element'/>
    </function>
    <function name='xsltParseStylesheetAttributeSet' file='attributes'>
      <info>parse an XSLT stylesheet attribute-set element</info>
      <return type='void'/>
      <arg name='style' type='xsltStylesheetPtr' info='the XSLT stylesheet'/>
      <arg name='cur' type='xmlNodePtr' info='the &quot;attribute-set&quot; element'/>
    </function>
    <function name='xsltParseStylesheetCallerParam' file='variables'>
      <info>parse an XSLT transformation param declaration, compute its value but doesn&apos;t record it.</info>
      <return type='xsltStackElemPtr' info='the new xsltStackElemPtr or NULL'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='the XSLT transformation context'/>
      <arg name='cur' type='xmlNodePtr' info='the &quot;param&quot; element'/>
    </function>
    <function name='xsltParseStylesheetDoc' file='xsltInternals'>
      <info>parse an XSLT stylesheet building the associated structures</info>
      <return type='xsltStylesheetPtr' info='a new XSLT stylesheet structure.'/>
      <arg name='doc' type='xmlDocPtr' info='and xmlDoc parsed XML'/>
    </function>
    <function name='xsltParseStylesheetFile' file='xsltInternals'>
      <info>Load and parse an XSLT stylesheet</info>
      <return type='xsltStylesheetPtr' info='a new XSLT stylesheet structure.'/>
      <arg name='filename' type='const xmlChar *' info='the filename/URL to the stylesheet'/>
    </function>
    <function name='xsltParseStylesheetImport' file='imports'>
      <info>parse an XSLT stylesheet import element</info>
      <return type='int' info='0 in case of success -1 in case of failure.'/>
      <arg name='style' type='xsltStylesheetPtr' info='the XSLT stylesheet'/>
      <arg name='cur' type='xmlNodePtr' info='the import element'/>
    </function>
    <function name='xsltParseStylesheetImportedDoc' file='xsltInternals'>
      <info>parse an XSLT stylesheet building the associated structures except the processing not needed for imported documents.</info>
      <return type='xsltStylesheetPtr' info='a new XSLT stylesheet structure.'/>
      <arg name='doc' type='xmlDocPtr' info='and xmlDoc parsed XML'/>
    </function>
    <function name='xsltParseStylesheetInclude' file='imports'>
      <info>parse an XSLT stylesheet include element</info>
      <return type='int' info='0 in case of success -1 in case of failure'/>
      <arg name='style' type='xsltStylesheetPtr' info='the XSLT stylesheet'/>
      <arg name='cur' type='xmlNodePtr' info='the include node'/>
    </function>
    <function name='xsltParseStylesheetOutput' file='xsltInternals'>
      <info>parse an XSLT stylesheet output element and record information related to the stylesheet output</info>
      <return type='void'/>
      <arg name='style' type='xsltStylesheetPtr' info='the XSLT stylesheet'/>
      <arg name='cur' type='xmlNodePtr' info='the &quot;output&quot; element'/>
    </function>
    <function name='xsltParseStylesheetParam' file='variables'>
      <info>parse an XSLT transformation param declaration and record its value.</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='the XSLT transformation context'/>
      <arg name='cur' type='xmlNodePtr' info='the &quot;param&quot; element'/>
    </function>
    <function name='xsltParseStylesheetProcess' file='xsltInternals'>
      <info>parse an XSLT stylesheet adding the associated structures</info>
      <return type='xsltStylesheetPtr' info='the value of the &apos;ret&apos; parameter if everything went right, NULL if something went amiss.'/>
      <arg name='ret' type='xsltStylesheetPtr' info='the XSLT stylesheet'/>
      <arg name='doc' type='xmlDocPtr' info='and xmlDoc parsed XML'/>
    </function>
    <function name='xsltParseStylesheetVariable' file='variables'>
      <info>parse an XSLT transformation variable declaration and record its value.</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='the XSLT transformation context'/>
      <arg name='cur' type='xmlNodePtr' info='the &quot;variable&quot; element'/>
    </function>
    <function name='xsltParseTemplateContent' file='xsltInternals'>
      <info>parse a template content-model Clean-up the template content from unwanted ignorable blank nodes and process xslt:text</info>
      <return type='void'/>
      <arg name='style' type='xsltStylesheetPtr' info='the XSLT stylesheet'/>
      <arg name='templ' type='xmlNodePtr' info='the container node (can be a document for literal results)'/>
    </function>
    <function name='xsltPreComputeExtModuleElement' file='extensions'>
      <info>Precomputes an extension module element</info>
      <return type='xsltElemPreCompPtr' info='the precomputed data'/>
      <arg name='style' type='xsltStylesheetPtr' info='the stylesheet'/>
      <arg name='inst' type='xmlNodePtr' info='the element node'/>
    </function>
    <functype name='xsltPreComputeFunction' file='extensions'>
      <info></info>
      <return type='xsltElemPreCompPtr' info=''/>
      <arg name='style' type='xsltStylesheetPtr' info=''/>
      <arg name='inst' type='xmlNodePtr' info=''/>
      <arg name='function' type='xsltTransformFunction' info=''/>
    </functype>
    <function name='xsltPrintErrorContext' file='xsltutils'>
      <info>Display the context of an error.</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='the transformation context'/>
      <arg name='style' type='xsltStylesheetPtr' info='the stylesheet'/>
      <arg name='node' type='xmlNodePtr' info='the current node being processed'/>
    </function>
    <function name='xsltProcessingInstruction' file='transform'>
      <info>Process the xslt processing-instruction node on the source node</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a XSLT process context'/>
      <arg name='node' type='xmlNodePtr' info='the node in the source tree.'/>
      <arg name='inst' type='xmlNodePtr' info='the xslt processing-instruction node'/>
      <arg name='comp' type='xsltStylePreCompPtr' info='precomputed information'/>
    </function>
    <function name='xsltProfileStylesheet' file='transform'>
      <info>Apply the stylesheet to the document and dump the profiling to the given output.</info>
      <return type='xmlDocPtr' info='the result document or NULL in case of error'/>
      <arg name='style' type='xsltStylesheetPtr' info='a parsed XSLT stylesheet'/>
      <arg name='doc' type='xmlDocPtr' info='a parsed XML document'/>
      <arg name='params' type='const char **' info='a NULL terminated arry of parameters names/values tuples'/>
      <arg name='output' type='FILE *' info='a FILE * for the profiling output'/>
    </function>
    <function name='xsltQuoteOneUserParam' file='variables'>
      <info>This is normally called from xsltQuoteUserParams to process a single parameter from a list of parameters.  The @value is stored in the context&apos;s global variable/parameter hash table.</info>
      <return type='int' info='0 in case of success, -1 in case of error.'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='the XSLT transformation context'/>
      <arg name='name' type='const xmlChar *' info='a null terminated string giving the name of the parameter'/>
      <arg name='value' type='const xmlChar *' info='a null terminated string giving the parameter value'/>
    </function>
    <function name='xsltQuoteUserParams' file='variables'>
      <info>Similar to xsltEvalUserParams, but the values are treated literally and are * *not* evaluated as XPath expressions. This should be done on parsed stylesheets before starting to apply transformations.</info>
      <return type='int' info='0 in case of success, -1 in case of error.'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='the XSLT transformation context'/>
      <arg name='params' type='const char **' info='a NULL terminated arry of parameters names/values tuples'/>
    </function>
    <function name='xsltRegisterAllElement' file='transform'>
      <info>Registers all default XSLT elements in this context</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='the XPath context'/>
    </function>
    <function name='xsltRegisterAllExtras' file='extra'>
      <info>Registers the built-in extensions</info>
      <return type='void'/>
    </function>
    <function name='xsltRegisterAllFunctions' file='functions'>
      <info>Registers all default XSLT functions in this context</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathContextPtr' info='the XPath context'/>
    </function>
    <function name='xsltRegisterExtElement' file='extensions'>
      <info>Registers an extension element</info>
      <return type='int' info='0 in case of success, -1 in case of failure'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context'/>
      <arg name='name' type='const xmlChar *' info='the name of the element'/>
      <arg name='URI' type='const xmlChar *' info='the URI associated to the element'/>
      <arg name='function' type='xsltTransformFunction' info='the actual implementation which should be called'/>
    </function>
    <function name='xsltRegisterExtFunction' file='extensions'>
      <info>Registers an extension function</info>
      <return type='int' info='0 in case of success, -1 in case of failure'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context'/>
      <arg name='name' type='const xmlChar *' info='the name of the element'/>
      <arg name='URI' type='const xmlChar *' info='the URI associated to the element'/>
      <arg name='function' type='xmlXPathFunction' info='the actual implementation which should be called'/>
    </function>
    <function name='xsltRegisterExtModule' file='extensions'>
      <info>Register an XSLT extension module to the library.</info>
      <return type='int' info='0 if sucessful, -1 in case of error'/>
      <arg name='URI' type='const xmlChar *' info='URI associated to this module'/>
      <arg name='initFunc' type='xsltExtInitFunction' info='the module initialization function'/>
      <arg name='shutdownFunc' type='xsltExtShutdownFunction' info='the module shutdown function'/>
    </function>
    <function name='xsltRegisterExtModuleElement' file='extensions'>
      <info>Registers an extension module element.</info>
      <return type='int' info='0 if successful, -1 in case of error.'/>
      <arg name='name' type='const xmlChar *' info='the element name'/>
      <arg name='URI' type='const xmlChar *' info='the element namespace URI'/>
      <arg name='precomp' type='xsltPreComputeFunction' info='the pre-computation callback'/>
      <arg name='transform' type='xsltTransformFunction' info='the transformation callback'/>
    </function>
    <function name='xsltRegisterExtModuleFull' file='extensions'>
      <info>Register an XSLT extension module to the library.</info>
      <return type='int' info='0 if sucessful, -1 in case of error'/>
      <arg name='URI' type='const xmlChar *' info='URI associated to this module'/>
      <arg name='initFunc' type='xsltExtInitFunction' info='the module initialization function'/>
      <arg name='shutdownFunc' type='xsltExtShutdownFunction' info='the module shutdown function'/>
      <arg name='styleInitFunc' type='xsltStyleExtInitFunction' info='the module initialization function'/>
      <arg name='styleShutdownFunc' type='xsltStyleExtShutdownFunction' info='the module shutdown function'/>
    </function>
    <function name='xsltRegisterExtModuleFunction' file='extensions'>
      <info>Registers an extension module function.</info>
      <return type='int' info='0 if successful, -1 in case of error.'/>
      <arg name='name' type='const xmlChar *' info='the function name'/>
      <arg name='URI' type='const xmlChar *' info='the function namespace URI'/>
      <arg name='function' type='xmlXPathFunction' info='the function callback'/>
    </function>
    <function name='xsltRegisterExtModuleTopLevel' file='extensions'>
      <info>Registers an extension module top-level element.</info>
      <return type='int' info='0 if successful, -1 in case of error.'/>
      <arg name='name' type='const xmlChar *' info='the top-level element name'/>
      <arg name='URI' type='const xmlChar *' info='the top-level element namespace URI'/>
      <arg name='function' type='xsltTopLevelFunction' info='the top-level element callback'/>
    </function>
    <function name='xsltRegisterExtPrefix' file='extensions'>
      <info>Registers an extension namespace</info>
      <return type='int' info='0 in case of success, -1 in case of failure'/>
      <arg name='style' type='xsltStylesheetPtr' info='an XSLT stylesheet'/>
      <arg name='prefix' type='const xmlChar *' info='the prefix used'/>
      <arg name='URI' type='const xmlChar *' info='the URI associated to the extension'/>
    </function>
    <function name='xsltRegisterExtras' file='extra'>
      <info>Registers the built-in extensions. This function is deprecated, use xsltRegisterAllExtras instead.</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a XSLT process context'/>
    </function>
    <function name='xsltRegisterPersistRVT' file='xsltInternals'>
      <info>Register the result value tree for destruction at the end of the processing</info>
      <return type='int' info='0 in case of success and -1 in case of error.'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context'/>
      <arg name='RVT' type='xmlDocPtr' info='a result value tree'/>
    </function>
    <function name='xsltRegisterTestModule' file='extensions'>
      <info>Registers the test module</info>
      <return type='void'/>
    </function>
    <function name='xsltRegisterTmpRVT' file='xsltInternals'>
      <info>Register the result value tree for destruction at the end of the context</info>
      <return type='int' info='0 in case of success and -1 in case of error.'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context'/>
      <arg name='RVT' type='xmlDocPtr' info='a result value tree'/>
    </function>
    <function name='xsltResolveStylesheetAttributeSet' file='attributes'>
      <info>resolve the references between attribute sets.</info>
      <return type='void'/>
      <arg name='style' type='xsltStylesheetPtr' info='the XSLT stylesheet'/>
    </function>
    <function name='xsltRunStylesheet' file='transform'>
      <info>Apply the stylesheet to the document and generate the output according to @output @SAX and @IObuf. It&apos;s an error to specify both @SAX and @IObuf.  NOTE: This may lead to a non-wellformed output XML wise ! NOTE: This may also result in multiple files being generated NOTE: using IObuf, the result encoding used will be the one used for creating the output buffer, use the following macro to read it from the stylesheet XSLT_GET_IMPORT_PTR(encoding, style, encoding) NOTE: using SAX, any encoding specified in the stylesheet will be lost since the interface uses only UTF8</info>
      <return type='int' info='the number of by written to the main resource or -1 in case of error.'/>
      <arg name='style' type='xsltStylesheetPtr' info='a parsed XSLT stylesheet'/>
      <arg name='doc' type='xmlDocPtr' info='a parsed XML document'/>
      <arg name='params' type='const char **' info='a NULL terminated arry of parameters names/values tuples'/>
      <arg name='output' type='const char *' info='the URL/filename ot the generated resource if available'/>
      <arg name='SAX' type='xmlSAXHandlerPtr' info='a SAX handler for progressive callback output (not implemented yet)'/>
      <arg name='IObuf' type='xmlOutputBufferPtr' info='an output buffer for progressive output (not implemented yet)'/>
    </function>
    <function name='xsltRunStylesheetUser' file='transform'>
      <info>Apply the stylesheet to the document and generate the output according to @output @SAX and @IObuf. It&apos;s an error to specify both @SAX and @IObuf.  NOTE: This may lead to a non-wellformed output XML wise ! NOTE: This may also result in multiple files being generated NOTE: using IObuf, the result encoding used will be the one used for creating the output buffer, use the following macro to read it from the stylesheet XSLT_GET_IMPORT_PTR(encoding, style, encoding) NOTE: using SAX, any encoding specified in the stylesheet will be lost since the interface uses only UTF8</info>
      <return type='int' info='the number of by written to the main resource or -1 in case of error.'/>
      <arg name='style' type='xsltStylesheetPtr' info='a parsed XSLT stylesheet'/>
      <arg name='doc' type='xmlDocPtr' info='a parsed XML document'/>
      <arg name='params' type='const char **' info='a NULL terminated arry of parameters names/values tuples'/>
      <arg name='output' type='const char *' info='the URL/filename ot the generated resource if available'/>
      <arg name='SAX' type='xmlSAXHandlerPtr' info='a SAX handler for progressive callback output (not implemented yet)'/>
      <arg name='IObuf' type='xmlOutputBufferPtr' info='an output buffer for progressive output (not implemented yet)'/>
      <arg name='profile' type='FILE *' info='profile FILE * output or NULL'/>
      <arg name='userCtxt' type='xsltTransformContextPtr' info='user provided transform context'/>
    </function>
    <function name='xsltSaveProfiling' file='xsltutils'>
      <info>Save the profiling informations on @output</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT context'/>
      <arg name='output' type='FILE *' info='a FILE * for saving the informations'/>
    </function>
    <function name='xsltSaveResultTo' file='xsltutils'>
      <info>Save the result @result obtained by applying the @style stylesheet to an I/O output channel @buf</info>
      <return type='int' info='the number of byte written or -1 in case of failure.'/>
      <arg name='buf' type='xmlOutputBufferPtr' info='an output buffer'/>
      <arg name='result' type='xmlDocPtr' info='the result xmlDocPtr'/>
      <arg name='style' type='xsltStylesheetPtr' info='the stylesheet'/>
    </function>
    <function name='xsltSaveResultToFd' file='xsltutils'>
      <info>Save the result @result obtained by applying the @style stylesheet to an open file descriptor This does not close the descriptor.</info>
      <return type='int' info='the number of bytes written or -1 in case of failure.'/>
      <arg name='fd' type='int' info='a file descriptor'/>
      <arg name='result' type='xmlDocPtr' info='the result xmlDocPtr'/>
      <arg name='style' type='xsltStylesheetPtr' info='the stylesheet'/>
    </function>
    <function name='xsltSaveResultToFile' file='xsltutils'>
      <info>Save the result @result obtained by applying the @style stylesheet to an open FILE * I/O. This does not close the FILE @file</info>
      <return type='int' info='the number of bytes written or -1 in case of failure.'/>
      <arg name='file' type='FILE *' info='a FILE * I/O'/>
      <arg name='result' type='xmlDocPtr' info='the result xmlDocPtr'/>
      <arg name='style' type='xsltStylesheetPtr' info='the stylesheet'/>
    </function>
    <function name='xsltSaveResultToFilename' file='xsltutils'>
      <info>Save the result @result obtained by applying the @style stylesheet to a file or @URL</info>
      <return type='int' info='the number of byte written or -1 in case of failure.'/>
      <arg name='URL' type='const char *' info='a filename or URL'/>
      <arg name='result' type='xmlDocPtr' info='the result xmlDocPtr'/>
      <arg name='style' type='xsltStylesheetPtr' info='the stylesheet'/>
      <arg name='compression' type='int' info='the compression factor (0 - 9 included)'/>
    </function>
    <function name='xsltSaveResultToString' file='xsltutils'>
      <info>Save the result @result obtained by applying the @style stylesheet to a file or @URL</info>
      <return type='int' info='the number of byte written or -1 in case of failure.'/>
      <arg name='doc_txt_ptr' type='xmlChar **' info='Memory pointer for allocated XML text'/>
      <arg name='doc_txt_len' type='int *' info='Length of the generated XML text'/>
      <arg name='result' type='xmlDocPtr' info='the result xmlDocPtr'/>
      <arg name='style' type='xsltStylesheetPtr' info='the stylesheet'/>
    </function>
    <function name='xsltSecurityAllow' file='security'>
      <info>Function used to always allow an operation</info>
      <return type='int' info='1 always'/>
      <arg name='sec' type='xsltSecurityPrefsPtr' info='the security block to use'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context'/>
      <arg name='value' type='const char *' info='unused'/>
    </function>
    <functype name='xsltSecurityCheck' file='security'>
      <info>User provided function to check the value of a string like a file path or an URL ...</info>
      <return type='int' info=''/>
      <arg name='sec' type='xsltSecurityPrefsPtr' info=''/>
      <arg name='ctxt' type='xsltTransformContextPtr' info=''/>
      <arg name='value' type='const char *' info=''/>
    </functype>
    <function name='xsltSecurityForbid' file='security'>
      <info>Function used to always forbid an operation</info>
      <return type='int' info='0 always'/>
      <arg name='sec' type='xsltSecurityPrefsPtr' info='the security block to use'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context'/>
      <arg name='value' type='const char *' info='unused'/>
    </function>
    <function name='xsltSetCtxtSecurityPrefs' file='security'>
      <info>Set the security preference for a specific transformation</info>
      <return type='int' info='-1 in case of error, 0 otherwise'/>
      <arg name='sec' type='xsltSecurityPrefsPtr' info='the security block to use'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context'/>
    </function>
    <function name='xsltSetCtxtSortFunc' file='xsltutils'>
      <info>Function to set the handler for XSLT sorting for the specified context. If the handler is NULL, then the global sort function will be called</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a XSLT process context'/>
      <arg name='handler' type='xsltSortFunc' info='the new handler function'/>
    </function>
    <function name='xsltSetDebuggerCallbacks' file='xsltutils'>
      <info>This function allow to plug a debugger into the XSLT library @block points to a block of memory containing the address of @no callback routines.</info>
      <return type='int' info='0 in case of success and -1 in case of error'/>
      <arg name='no' type='int' info='number of callbacks'/>
      <arg name='block' type='void *' info='the block of callbacks'/>
    </function>
    <function name='xsltSetDefaultSecurityPrefs' file='security'>
      <info>Set the default security preference application-wide</info>
      <return type='void'/>
      <arg name='sec' type='xsltSecurityPrefsPtr' info='the security block to use'/>
    </function>
    <function name='xsltSetGenericDebugFunc' file='xsltutils'>
      <info>Function to reset the handler and the error context for out of context error messages. This simply means that @handler will be called for subsequent error messages while not parsing or validating. And @ctx will be passed as first argument to @handler One can simply force messages to be emitted to another FILE * than stderr by setting @ctx to this file handle and @handler to NULL.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the new error handling context'/>
      <arg name='handler' type='xmlGenericErrorFunc' info='the new handler function'/>
    </function>
    <function name='xsltSetGenericErrorFunc' file='xsltutils'>
      <info>Function to reset the handler and the error context for out of context error messages. This simply means that @handler will be called for subsequent error messages while not parsing nor validating. And @ctx will be passed as first argument to @handler One can simply force messages to be emitted to another FILE * than stderr by setting @ctx to this file handle and @handler to NULL.</info>
      <return type='void'/>
      <arg name='ctx' type='void *' info='the new error handling context'/>
      <arg name='handler' type='xmlGenericErrorFunc' info='the new handler function'/>
    </function>
    <function name='xsltSetSecurityPrefs' file='security'>
      <info>Update the security option to use the new callback checking function</info>
      <return type='int' info='-1 in case of error, 0 otherwise'/>
      <arg name='sec' type='xsltSecurityPrefsPtr' info='the security block to update'/>
      <arg name='option' type='xsltSecurityOption' info='the option to update'/>
      <arg name='func' type='xsltSecurityCheck' info='the user callback to use for this option'/>
    </function>
    <function name='xsltSetSortFunc' file='xsltutils'>
      <info>Function to reset the global handler for XSLT sorting. If the handler is NULL, the default sort function will be used.</info>
      <return type='void'/>
      <arg name='handler' type='xsltSortFunc' info='the new handler function'/>
    </function>
    <function name='xsltSetTransformErrorFunc' file='xsltutils'>
      <info>Function to reset the handler and the error context for out of context error messages specific to a given XSLT transromation.  This simply means that @handler will be called for subsequent error messages while running the transformation.</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='the XSLT transformation context'/>
      <arg name='ctx' type='void *' info='the new error handling context'/>
      <arg name='handler' type='xmlGenericErrorFunc' info='the new handler function'/>
    </function>
    <function name='xsltSetXIncludeDefault' file='transform'>
      <info>Set whether XInclude should be processed on document being loaded by default</info>
      <return type='void'/>
      <arg name='xinclude' type='int' info='whether to do XInclude processing'/>
    </function>
    <function name='xsltShutdownCtxtExts' file='extensions'>
      <info>Shutdown the set of modules loaded</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context'/>
    </function>
    <function name='xsltShutdownExts' file='extensions'>
      <info>Shutdown the set of modules loaded</info>
      <return type='void'/>
      <arg name='style' type='xsltStylesheetPtr' info='an XSLT stylesheet'/>
    </function>
    <function name='xsltSort' file='transform'>
      <info>function attached to xsl:sort nodes, but this should not be called directly</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a XSLT process context'/>
      <arg name='node' type='xmlNodePtr' info='the node in the source tree.'/>
      <arg name='inst' type='xmlNodePtr' info='the xslt sort node'/>
      <arg name='comp' type='xsltStylePreCompPtr' info='precomputed information'/>
    </function>
    <functype name='xsltSortFunc' file='xsltInternals'>
      <info>Signature of the function to use during sorting</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a transformation context'/>
      <arg name='sorts' type='xmlNodePtr *' info='the node-set to sort'/>
      <arg name='nbsorts' type='int' info='the number of sorts'/>
    </functype>
    <functype name='xsltStyleExtInitFunction' file='extensions'>
      <info>A function called at initialization time of an XSLT extension module.</info>
      <return type='void *' info='a pointer to the module specific data for this transformation.'/>
      <arg name='style' type='xsltStylesheetPtr' info=''/>
      <arg name='URI' type='const xmlChar *' info='the namespace URI for the extension'/>
    </functype>
    <functype name='xsltStyleExtShutdownFunction' file='extensions'>
      <info>A function called at shutdown time of an XSLT extension module.</info>
      <return type='void'/>
      <arg name='style' type='xsltStylesheetPtr' info=''/>
      <arg name='URI' type='const xmlChar *' info='the namespace URI for the extension'/>
      <arg name='data' type='void *' info='the data associated to this module'/>
    </functype>
    <function name='xsltStyleGetExtData' file='extensions'>
      <info>Retrieve the data associated to the extension module in this given stylesheet.</info>
      <return type='void *' info='the pointer or NULL if not present'/>
      <arg name='style' type='xsltStylesheetPtr' info='an XSLT stylesheet'/>
      <arg name='URI' type='const xmlChar *' info='the URI associated to the exension module'/>
    </function>
    <function name='xsltStylePreCompute' file='preproc'>
      <info>Precompute an XSLT stylesheet element</info>
      <return type='void'/>
      <arg name='style' type='xsltStylesheetPtr' info='the XSLT stylesheet'/>
      <arg name='inst' type='xmlNodePtr' info='the instruction in the stylesheet'/>
    </function>
    <function name='xsltSystemPropertyFunction' file='functions'>
      <info>Implement the system-property() XSLT function object system-property(string)</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context'/>
      <arg name='nargs' type='int' info='the number of arguments'/>
    </function>
    <function name='xsltTemplateProcess' file='templates'>
      <info>Process the given node and return the new string value.</info>
      <return type='xmlNodePtr *' info='the computed tree replacement'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='the XSLT transformation context'/>
      <arg name='node' type='xmlNodePtr' info='the attribute template node'/>
    </function>
    <function name='xsltTestCompMatchList' file='pattern'>
      <info>Test wether the node matches one of the patterns in the list</info>
      <return type='int' info='1 if it matches, 0 if it doesn&apos;t and -1 in case of failure'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a XSLT process context'/>
      <arg name='node' type='xmlNodePtr' info='a node'/>
      <arg name='comp' type='xsltCompMatchPtr' info='the precompiled pattern list'/>
    </function>
    <function name='xsltText' file='transform'>
      <info>Process the xslt text node on the source node</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a XSLT process context'/>
      <arg name='node' type='xmlNodePtr' info='the node in the source tree.'/>
      <arg name='inst' type='xmlNodePtr' info='the xslt text node'/>
      <arg name='comp' type='xsltStylePreCompPtr' info='precomputed information'/>
    </function>
    <function name='xsltTimestamp' file='xsltutils'>
      <info>Used for gathering profiling data</info>
      <return type='long' info='the number of tenth of milliseconds since the beginning of the profiling'/>
    </function>
    <functype name='xsltTopLevelFunction' file='extensions'>
      <info></info>
      <return type='void'/>
      <arg name='style' type='xsltStylesheetPtr' info=''/>
      <arg name='inst' type='xmlNodePtr' info=''/>
    </functype>
    <function name='xsltTransformError' file='xsltutils'>
      <info>Display and format an error messages, gives file, line, position and extra parameters, will use the specific transformation context if available</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='an XSLT transformation context'/>
      <arg name='style' type='xsltStylesheetPtr' info='the XSLT stylesheet used'/>
      <arg name='node' type='xmlNodePtr' info='the current node in the stylesheet'/>
      <arg name='msg' type='const char *' info='the message to display/transmit'/>
      <arg name='...' type='...' info='extra parameters for the message display'/>
    </function>
    <functype name='xsltTransformFunction' file='xsltInternals'>
      <info>Signature of the function associated to elements part of the stylesheet language like xsl:if or xsl:apply-templates.</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='the XSLT transformation context'/>
      <arg name='node' type='xmlNodePtr' info='the input node'/>
      <arg name='inst' type='xmlNodePtr' info='the stylesheet node'/>
      <arg name='comp' type='xsltElemPreCompPtr' info='the compiled information from the stylesheet'/>
    </functype>
    <function name='xsltUnparsedEntityURIFunction' file='functions'>
      <info>Implement the unparsed-entity-uri() XSLT function string unparsed-entity-uri(string)</info>
      <return type='void'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='the XPath Parser context'/>
      <arg name='nargs' type='int' info='the number of arguments'/>
    </function>
    <function name='xsltUnregisterExtModule' file='extensions'>
      <info>Unregister an XSLT extension module from the library.</info>
      <return type='int' info='0 if sucessful, -1 in case of error'/>
      <arg name='URI' type='const xmlChar *' info='URI associated to this module'/>
    </function>
    <function name='xsltUnregisterExtModuleElement' file='extensions'>
      <info>Unregisters an extension module element</info>
      <return type='int' info='0 if successful, -1 in case of error.'/>
      <arg name='name' type='const xmlChar *' info='the element name'/>
      <arg name='URI' type='const xmlChar *' info='the element namespace URI'/>
    </function>
    <function name='xsltUnregisterExtModuleFunction' file='extensions'>
      <info>Unregisters an extension module function</info>
      <return type='int' info='0 if successful, -1 in case of error.'/>
      <arg name='name' type='const xmlChar *' info='the function name'/>
      <arg name='URI' type='const xmlChar *' info='the function namespace URI'/>
    </function>
    <function name='xsltUnregisterExtModuleTopLevel' file='extensions'>
      <info>Unregisters an extension module top-level element</info>
      <return type='int' info='0 if successful, -1 in case of error.'/>
      <arg name='name' type='const xmlChar *' info='the top-level element name'/>
      <arg name='URI' type='const xmlChar *' info='the top-level element namespace URI'/>
    </function>
    <function name='xsltValueOf' file='transform'>
      <info>Process the xslt value-of node on the source node</info>
      <return type='void'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='a XSLT process context'/>
      <arg name='node' type='xmlNodePtr' info='the node in the source tree.'/>
      <arg name='inst' type='xmlNodePtr' info='the xslt value-of node'/>
      <arg name='comp' type='xsltStylePreCompPtr' info='precomputed information'/>
    </function>
    <function name='xsltVariableLookup' file='variables'>
      <info>Search in the Variable array of the context for the given variable value.</info>
      <return type='xmlXPathObjectPtr' info='the value or NULL if not found'/>
      <arg name='ctxt' type='xsltTransformContextPtr' info='the XSLT transformation context'/>
      <arg name='name' type='const xmlChar *' info='the variable name'/>
      <arg name='ns_uri' type='const xmlChar *' info='the variable namespace URI'/>
    </function>
    <function name='xsltXPathFunctionLookup' file='functions'>
      <info>This is the entry point when a function is needed by the XPath interpretor.</info>
      <return type='xmlXPathFunction' info='the callback function or NULL if not found'/>
      <arg name='ctxt' type='xmlXPathContextPtr' info='a void * but the XSLT transformation context actually'/>
      <arg name='name' type='const xmlChar *' info='the function name'/>
      <arg name='ns_uri' type='const xmlChar *' info='the function namespace URI'/>
    </function>
    <function name='xsltXPathGetTransformContext' file='extensions'>
      <info>Provides the XSLT transformation context from the XPath transformation context. This is useful when an XPath function in the extension module is called by the XPath interpreter and that the XSLT context is needed for example to retrieve the associated data pertaining to this XSLT transformation.</info>
      <return type='xsltTransformContextPtr' info='the XSLT transformation context or NULL in case of error.'/>
      <arg name='ctxt' type='xmlXPathParserContextPtr' info='an XPath transformation context'/>
    </function>
    <function name='xsltXPathVariableLookup' file='variables'>
      <info>This is the entry point when a varibale is needed by the XPath interpretor.</info>
      <return type='xmlXPathObjectPtr' info='the value or NULL if not found'/>
      <arg name='ctxt' type='void *' info='a void * but the the XSLT transformation context actually'/>
      <arg name='name' type='const xmlChar *' info='the variable name'/>
      <arg name='ns_uri' type='const xmlChar *' info='the variable namespace URI'/>
    </function>
  </symbols>
</api>
